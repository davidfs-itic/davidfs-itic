{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3 Cicles Formatius Fam\u00edlia Inform\u00e0tica","text":""},{"location":"#contingut","title":"Contingut","text":"<ul> <li>Android</li> <li> <p>Exemples de codi Android</p> </li> <li> <p>Arduino </p> </li> <li> <p>IoT</p> </li> </ul>"},{"location":"#_1","title":"Inici","text":""},{"location":"Android/","title":"Introducci\u00f3 al desenvolupament en Android","text":""},{"location":"Android/#contingut","title":"Contingut","text":"<ul> <li>Llenguatge Kotlin</li> <li>Interficies</li> <li>Arquitectura</li> <li>Llibreries</li> <li>Firebase</li> </ul>"},{"location":"Android/activities/","title":"Activities","text":""},{"location":"Android/fragments/","title":"Fragments","text":"<p>Documentaci\u00f3 oficial</p> <ul> <li>https://developer.android.com/guide/fragments</li> </ul> <p>Exemple pas a pas - https://cursokotlin.com/capitulo-22-fragments-en-kotlin/</p>"},{"location":"Android/fragments/#1-introduccio-als-fragments-que-son-i-per-que-utilitzar-los","title":"1-Introducci\u00f3 als Fragments Qu\u00e8 s\u00f3n i per qu\u00e8 utilitzar-los?","text":"<p>Definici\u00f3: Components reutilitzables d'UI que representen una part d'una pantalla dins d'una Activity. Cada fragment t\u00e9 el seu cicle de vida. Han d'existir dins d'una activity o d'un altre fragment.</p> <p>Avantatges:</p> <ul> <li> <p>Reutilitzaci\u00f3: El mateix fragment pot usar-se en m\u00faltiples activities.</p> </li> <li> <p>Disseny adaptable: Diferents layouts per m\u00f2bils/tablets.</p> </li> <li> <p>Modularitat: Divideix la UI en components independents.</p> </li> <li> <p>Comparaci\u00f3: Els fragments s\u00f3n com \"sub-activitats\" amb cicle de vida propi.</p> </li> </ul> <p>Mostra visual d'una activity amb 2 fragments: </p>"},{"location":"Android/fragments/#2-anatomia-dun-fragment","title":"2-Anatomia d'un Fragment","text":""},{"location":"Android/fragments/#estructura-basica","title":"Estructura b\u00e0sica","text":"<p>Els fragments tenen layouts igual que les activities, en xml.</p> <p>Tamb\u00e9 tenen la seva classe Fragment() de la qual herata i sobreescriu m\u00e8todes clau: <pre><code>class NewFragment : Fragment() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n    }\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_blank, container, false)\n    }\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        val someInt = requireArguments().getInt(\"some_int\")\n        ...\n    }    \n</code></pre></p>"},{"location":"Android/fragments/#metodes-essencials","title":"M\u00e8todes essencials:","text":"<ul> <li> <p>onCreateView(): Infla el layout i retorna la View.</p> </li> <li> <p>onViewCreated(): Configura les vistes un cop creades.</p> </li> </ul>"},{"location":"Android/fragments/#cicle-de-vida-del-fragment","title":"Cicle de vida del Fragment","text":"<p>Punt important: onDestroyView() es crida abans que onDestroy(), alliberant la vista.</p> <p>Refer\u00e8ncia: Cicle de vida dels Fragments: https://developer.android.com/guide/fragments/lifecycle</p>"},{"location":"Android/fragments/#3-implementacio-basica","title":"3-Implementaci\u00f3 B\u00e0sica","text":""},{"location":"Android/fragments/#afegir-fragments-a-una-activity","title":"Afegir fragments a una Activity","text":"<p>M\u00e8tode est\u00e0tic: Via XML amb etiqueta (per fragments fixos). <pre><code>&lt;androidx.fragment.app.FragmentContainerView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/fragmentContainerView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" /&gt;\n</code></pre> M\u00e8tode din\u00e0mic: Via FragmentManager i FragmentTransaction (m\u00e9s flexible).</p>"},{"location":"Android/fragments/#fragmentmanager-i-fragmenttransaction","title":"FragmentManager i FragmentTransaction","text":"<p>Refer\u00e8ncies: https://developer.android.com/guide/fragments/fragmentmanager</p> <p>El fragmentmanager \u00e9s la classe responsable d'afegir, eliminar i la resta d'accions sobre un fragment. Al fragmentmanager hi accedim des de l'activity a trav\u00e9s de la funci\u00f3 supportFragmentManager.</p> <p>Des del fragment, podem accedir al fragmentmanager de la app, amb la funci\u00f3 getParentFragmentManager().</p> <p></p>"},{"location":"Android/fragments/#afegir-fragment-a-un-fragmentcontainer","title":"Afegir fragment a un fragmentcontainer","text":"<p>Hi ha 2 maneres de carregar un fragment, afegint-lo a l'stack, o reempla\u00e7ant-lo.</p> <ul> <li>BackStack: Permet tornar enrrere per tota la pila (stack) de fragments afegits.</li> <li>Replace: Substitueix la pila anterior per un altre. Nom\u00e9s es pot tornar al fragment substituit.</li> </ul> <p></p> <pre><code>    //Afegeix el fragment i l'afegeix a la pila (backstack)\n    // de manera que tornar enrrere, tornara al fragment anterior.\n    private fun addFragment(fragment: Fragment,args : Bundle?) {\n        fragment.arguments = args\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.fragmentbottom, fragment)\n        fragmentTransaction.addToBackStack(null)\n        fragmentTransaction.commit()\n    }\n    //Intercanvia el fragment. Tornar enrrere no tornara al fragment anterior.\n    private fun replaceFragment(fragment: Fragment,args : Bundle?){\n        fragment.arguments = args\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.replace(R.id.fragmentbottom, fragment)\n        fragmentTransaction.commit()\n    }\n</code></pre> <p>Amb la versi\u00f3 m\u00e9s moderna (segons la documentaci\u00f3 de android).</p> <p>Cal afegir les dependiencies: <pre><code>dependencies {\n    implementation \"androidx.fragment:fragment-ktx:1.6.2\"\n    // o la versi\u00f3 m\u00e9s recent disponible\n}\n</code></pre></p> <p>i el codi es transforma en el seg\u00fcent:</p> <pre><code>private fun addFragment(fragment: Fragment, args: Bundle?) {\n    supportFragmentManager.commit {\n        setReorderingAllowed(true)\n        add(R.id.fragmentbottom, fragment::class.java, args)\n        addToBackStack(null)\n    }\n}\n</code></pre>"},{"location":"Android/fragments/#4-comunicacio","title":"4-Comunicaci\u00f3","text":""},{"location":"Android/fragments/#accedir-a-lactivity-des-del-fragment","title":"Accedir a l'Activity des del Fragment","text":"<p>De vegades necessitem accedir a l'activity, per exemple si necessitem modificar la appbar o toolbar.</p> <pre><code>// Forma segura - llan\u00e7a excepci\u00f3 si no hi ha activity\nval activity = requireActivity()\n\n// Forma nullable - retorna null si no hi ha activity  \nval activity = activity\n\n// Modificar Toolbar\n(requireActivity() as AppCompatActivity).supportActionBar?.title = \"Nou T\u00edtol\"\n</code></pre>"},{"location":"Android/fragments/#patro-de-callbacks","title":"Patr\u00f3 de Callbacks","text":"<p><pre><code>class ExempleFragment : Fragment() {\n\n    interface OnDataListener {\n        fun onDataReceived(data: String)\n    }\n\n    private var callback: OnDatatListener? = null\n\n    override fun onAttach(context: Context) {\n        super.onAttach(context)\n        if (context is OnDataListener) {\n            callback = context\n        } else {\n            throw RuntimeException(\"$context must implement OnDataListener\")\n        }\n    }\n\n    override fun onDetach() {\n        super.onDetach()\n        callback = null\n    }\n\n    // Exemple: alg\u00fa prem un bot\u00f3 al fragment\n    private fun enviarDades() {\n        callback?.onDataReceived(\"Hola des del fragment!\")\n    }\n}\n\nclass MainActivity : AppCompatActivity(), ExempleFragment.OnDataListener {\n\n    override fun onDataReceived(data: String) {\n        // Fer alguna cosa amb les dades rebudes\n        Log.d(\"MainActivity\", data)\n    }\n}\n</code></pre> Avantatge: Desacobla el fragment de l'activity espec\u00edfica.</p>"},{"location":"Android/fragments/#amb-shared-viewmodels","title":"Amb shared Viewmodels","text":"<p>Vegeu documentaci\u00f3 a Shared Viewmodels</p>"},{"location":"Android/fragments/#5-animacio-de-les-transicions-entre-fragments","title":"5-Animaci\u00f3 de les transicions entre fragments","text":"<p>Podem definir les animacions a la carpeta res/anim (tipus anim)</p> <p>Arxius:</p> <p>fade_out.xml <pre><code>&lt;!-- res/anim/fade_out.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:interpolator=\"@android:anim/decelerate_interpolator\"\n    android:fromAlpha=\"1\"\n    android:toAlpha=\"0\" /&gt;\n</code></pre></p> <p>fade_in.xml <pre><code>&lt;!-- res/anim/slide_in.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:interpolator=\"@android:anim/decelerate_interpolator\"\n    android:fromXDelta=\"100%\"\n    android:toXDelta=\"0%\" /&gt;\n</code></pre> En la transacci\u00f3 que intercanvia els fragments</p> <pre><code>        fragmentTransaction.setCustomAnimations(\n            R.anim.fade_out, // exit\n            R.anim.fade_in, // popEnter\n        )\n</code></pre>"},{"location":"Android/fragments/#definir-la-animacio-en-entrar-o-sortir-en-el-oncreate","title":"Definir la animacio en entrar o sortir en el onCreate","text":"<p>Es creen els arxius en la carpeta res/transition (type transition)</p> <p>Arxiu fade.xml <pre><code>&lt;!-- res/transition/fade.xml --&gt;\n&lt;fade xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"/&gt;\n</code></pre> Arxiu slide.xml <pre><code>&lt;slide xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:slideEdge=\"right\" /&gt;\n</code></pre></p> <p>en els fragments: <pre><code>class FragmentA : Fragment() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val inflater = TransitionInflater.from(requireContext())\n        exitTransition = inflater.inflateTransition(R.transition.fade)\n    }\n}\n\nclass FragmentB : Fragment() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val inflater = TransitionInflater.from(requireContext())\n        enterTransition = inflater.inflateTransition(R.transition.slide_right)\n    }\n}\n</code></pre></p>"},{"location":"Android/Arquitectura/","title":"Arquitectura","text":"<p>Si seguim les indicacions de google i de molts altres desenvolupadors, veurem que qualsevol aplicaci\u00f3 ha d'estar estructurada per \"capes\", o funcionalitats separades.</p> <p>Vegeu com a refer\u00e8ncia aquest document: https://developer.android.com/topic/architecture</p> <p>Cursos (tutorial) de Android: https://developer.android.com/courses/pathways/android-architecture</p> <p>Elements de l'arquitectura:</p> <ul> <li>ViewModel</li> <li>Application ViewModel</li> <li>Observer</li> <li>Dommini (Repositori) i Dades</li> <li>Inversi\u00f3 de Depend\u00e8ncies</li> <li>Patr\u00f3 Factory</li> <li>Exemple DIP recycler </li> <li>Principis SOLID</li> </ul>"},{"location":"Android/Arquitectura/applicationviewmodel/","title":"Application ViewModel","text":""},{"location":"Android/Arquitectura/applicationviewmodel/#1-que-es-lapplicationviewmodel","title":"1. Qu\u00e8 \u00e9s l'ApplicationViewModel","text":"<p>ApplicationViewModel es refereix a una inst\u00e0ncia de ViewModel que est\u00e0 vinculada al cicle de vida de l'aplicaci\u00f3 sencera mitjan\u00e7ant la classe Application d'Android.</p> <p>\u00c0mbit (Scope): Si un ViewModel s'associa amb l'objecte Application (que actua com a ViewModelStoreOwner), aquest ViewModel existir\u00e0 durant tota la vida de l'aplicaci\u00f3. Es destrueix nom\u00e9s quan el proc\u00e9s de l'aplicaci\u00f3 es finalitza pel sistema operatiu.</p> <p>AndroidViewModel: La classe AndroidViewModel \u00e9s una subclasse de ViewModel que rep l'objecte Application al seu constructor, cosa que li permet accedir a recursos a nivell d'aplicaci\u00f3 (com Context) de manera segura (sense provocar fugues de mem\u00f2ria).</p> <p>L'Application ViewModel s'utilitza principalment per a la gesti\u00f3 de dades a nivell global que han de sobreviure a tota la vida de l'aplicaci\u00f3 i ser accessibles des de qualsevol punt de la UI.</p> <p>\u00c9s important notar que, en lloc d'utilitzar directament la classe base ViewModel, utilitzem la seva subclasse AndroidViewModel.</p> <p>Refer\u00e8ncia: https://www.youtube.com/watch?v=THt9QISnIMQ&amp;t=51s</p>"},{"location":"Android/Arquitectura/applicationviewmodel/#2-creacio-de-landroidviewmodel","title":"2. Creaci\u00f3 de l'AndroidViewModel:","text":"<p>Per crear un \"Application ViewModel\" de forma correcta, cal estendre la classe AndroidViewModel</p> <pre><code>// Exemple: Aplicaci\u00f3 per gestionar les prefer\u00e8ncies d'usuari globals\nclass AppViewModel(application: Application) : AndroidViewModel(application) {\n\n    // 1. Variable privada modificable (MutableLiveData)\n    private val _counter = MutableLiveData&lt;Int&gt;() \n\n    // 2. Variable p\u00fablica no modificable (LiveData)\n    // Aquesta \u00e9s la variable que les Vistes (Fragments/Activities) observaran.\n    val counter: LiveData&lt;Int&gt; = _counter\n\n    // 3. Inicialitzaci\u00f3\n    init {\n        _counter.value = 0 \n    }\n\n    // 4. M\u00e8tode per modificar l'estat (la l\u00f2gica de negoci)\n    fun incrementCounter() {\n        // Utilitzem el m\u00e8tode 'value' per assignaci\u00f3 s\u00edncrona\n        val currentValue = _counter.value ?: 0\n        _counter.value = currentValue + 1\n    }\n\n    fun decrementCounter() {\n        val currentValue = _counter.value ?: 0\n        _counter.value = currentValue - 1\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/applicationviewmodel/#3-instanciacio","title":"3. Instanciaci\u00f3","text":"<p>Des d'una Activity o un Fragment, s'utilitza la funci\u00f3 de delegat viewModels()</p> <p>En realitat, el framework de ViewModel ja gestiona autom\u00e0ticament la depend\u00e8ncia de l'Application quan detecta que s'est\u00e0 utilitzant la subclasse AndroidViewModel.</p> <pre><code>private val appViewModel: AppPreferencesViewModel by viewModels()\n</code></pre> <p>No cal que passis expl\u00edcitament l'objecte Application a viewModels() o a ViewModelProvider perqu\u00e8 el sistema ja s'encarrega de fer-ho autom\u00e0ticament per tu quan utilitzes la subclasse correcta.</p> <p>Quan crides a viewModels(), Android utilitza un objecte anomenat ViewModelProvider.Factory. Per defecte, si no en proporciones un de propi, s'utilitza el DefaultViewModelProviderFactory.</p> <p>Aquesta Factory per defecte cont\u00e9 l\u00f2gica espec\u00edfica per gestionar els dos casos m\u00e9s comuns:</p>"},{"location":"Android/Arquitectura/applicationviewmodel/#cas-1-viewmodel-base-class-myviewmodel-viewmodel","title":"Cas 1: ViewModel Base (class MyViewModel : ViewModel)","text":"<p>La Factory intenta instanciar-lo directament utilitzant el seu constructor sense arguments (constructor buit).</p>"},{"location":"Android/Arquitectura/applicationviewmodel/#cas-2-androidviewmodel-class-myappviewmodel-androidviewmodel","title":"Cas 2: AndroidViewModel (class MyAppViewModel : AndroidViewModel)","text":"<p>La Factory detecta que la classe del ViewModel sol\u00b7licitat \u00e9s una subclasse d'AndroidViewModel.</p> <p>Quan detecta AndroidViewModel, autom\u00e0ticament mira el ViewModelStoreOwner (que \u00e9s el teu Activity o Fragment) i n'extreu l'objecte Application associat (a trav\u00e9s del Context ).</p> <p>Finalment, utilitza aquest objecte Application per cridar al constructor de la teva classe: AppPreferencesViewModel(application).</p> <p>Info</p> <p>Tota Activity i Fragment t\u00e9 acc\u00e9s al Context, i mitjan\u00e7ant el context, es pot accedir a l'objecte Application de l'aplicaci\u00f3. $$\\text{Activity/Fragment} \\rightarrow \\text{Context} \\rightarrow \\text{Application}$$</p>"},{"location":"Android/Arquitectura/applicationviewmodel/#4-utilitzacio","title":"4. Utilitzaci\u00f3","text":"<pre><code>class CounterFragment : Fragment() {\n\n    // Instanciaci\u00f3: Obtenim la mateixa inst\u00e0ncia del ViewModel Global\n    // El sistema sap que \u00e9s un AndroidViewModel i li passa l'Application\n    private val appViewModel: AppViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        appViewModel.counter.observe(viewLifecycleOwner) { count -&gt;\n            // Actualitzaci\u00f3 autom\u00e0tica de la UI quan canvia el valor\n            counterTextView.text = \"Comptador Global: $count\"\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/factory/","title":"Patr\u00f3 Factory","text":""},{"location":"Android/Arquitectura/factory/#1-que-es","title":"1. Qu\u00e8 \u00e9s?","text":"<p>El patr\u00f3 Factory \u00e9s un patr\u00f3 de disseny que proporciona una manera de crear objectes sense especificar la classe exacta de l'objecte que crear\u00e0. En comptes d'aix\u00f3, es confia a un m\u00e9tode \"factory\" que crei i retorni l'objecte, tipicament basat en par\u00e0metres d'entrada o configuraci\u00f3.</p> <p>El principi fonamental \u00e9s que el codi que necessita un objecte, interactua amb una interf\u00edcie comuna i no necessita saber exactament quina classe concreta s'est\u00e0 instant. El \"Factory\" \u00e9s l'entitat responsable de decidir i crear la inst\u00e0ncia correcta.</p>"},{"location":"Android/Arquitectura/factory/#components-del-patro","title":"Components del patr\u00f3:","text":"<ul> <li> <p>Una Interf\u00edcie/Classe Base del \"Producte\": Defineix el contracte com\u00fa que tots els objectes creats pel Factory han de seguir. A Kotlin, aix\u00f2 sol ser una interface o una abstract class.</p> </li> <li> <p>Productes Concrets: S\u00f3n les classes que implementen la interf\u00edcie del Producte. S\u00f3n les inst\u00e0ncies que el Factory crear\u00e0.</p> </li> <li> <p>El Factory: La classe o funci\u00f3 que cont\u00e9 la l\u00f2gica per decidir quin Producte Concret instanciar i retornar.</p> </li> </ul>"},{"location":"Android/Arquitectura/factory/#com-simplementa","title":"Com s'implementa?","text":"<p>Imagina que necessitem mostrar diferents tipus de Notificacions (per exemple, una notificaci\u00f3 simple, una amb imatge, o una de progr\u00e9s). </p> <p>En lloc que cada part del teu codi d'Android (com una Activity o ViewModel) s\u00e0piga com construir cada tipus de notificaci\u00f3 amb els seus par\u00e0metres espec\u00edfics, podem usar un Factory.</p>"},{"location":"Android/Arquitectura/factory/#1-interficie-del-producte-notification","title":"1. Interf\u00edcie del \"Producte\" (Notification)","text":"<p>Definim la interf\u00edcie comuna que totes les notificacions han d'implementar.</p> <pre><code>interface AppNotification {\n    fun show(context: Context)\n}\n</code></pre>"},{"location":"Android/Arquitectura/factory/#2-productes-concrets-simple-image-progress-notification","title":"2. Productes Concrets (Simple, Image, Progress Notification)","text":"<p>Implementem les classes espec\u00edfiques de notificacions.</p> <pre><code>class SimpleNotification(private val message: String) : AppNotification {\n    override fun show(context: Context) {\n        // L\u00f2gica de construcci\u00f3 d'una notificaci\u00f3 simple d'Android\n        println(\"Mostrant notificaci\u00f3 simple: $message\")\n    }\n}\n\nclass ImageNotification(private val imageUrl: String) : AppNotification {\n    override fun show(context: Context) {\n        // L\u00f2gica de construcci\u00f3 amb imatge (m\u00e9s complexa)\n        println(\"Mostrant notificaci\u00f3 amb imatge des de: $imageUrl\")\n    }\n}\n// Podria haver-n'hi m\u00e9s, com ProgressNotification, etc.\n</code></pre>"},{"location":"Android/Arquitectura/factory/#3-el-factory-notificationfactory","title":"3. El Factory (NotificationFactory)","text":"<p>Creem un objecte object (que actua com un Singleton a Kotlin) amb una funci\u00f3 que decideix quin tipus de producte instanciar basant-se en el parametre type</p> <pre><code>// Usem una 'sealed class' o 'enum' per definir els tipus\nsealed class NotificationType {\n    data class Simple(val message: String) : NotificationType()\n    data class Image(val url: String) : NotificationType()\n    object Progress : NotificationType() // Exemple d'un tipus simple\n}\n\nobject NotificationFactory {\n\n    fun createNotification(type: NotificationType): AppNotification = when (type) {\n        is NotificationType.Simple -&gt; SimpleNotification(type.message)\n        is NotificationType.Image -&gt; ImageNotification(type.url)\n        NotificationType.Progress -&gt; ProgressNotification() // Assumint que existeix\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/factory/#4-us-a-activityviewmodel","title":"4. \u00das a Activity/ViewModel","text":"<p>Ara, en el codi d'Android, nom\u00e9s cal cridar al Factory i treballar amb la interf\u00edcie AppNotification, sense preocupar-se pels detalls de creaci\u00f3.</p> <pre><code>// En una Activity o ViewModel\nfun showNotification(data: MessageData, context: Context) {\n    val type = if (data.hasImage) {\n        NotificationType.Image(data.imageUrl)\n    } else {\n        NotificationType.Simple(data.text)\n    }\n\n    // El codi de la Activity nom\u00e9s interactua amb el Factory i la interf\u00edcie\n    val notification = NotificationFactory.createNotification(type)\n    notification.show(context)\n}\n</code></pre>"},{"location":"Android/Arquitectura/factory/#resum","title":"Resum","text":"<p>El Patr\u00f3 Factory no s'utilitza per amagar qu\u00e8 vols crear, sin\u00f3 COM es crea.</p> <p>S'oculta:</p>"},{"location":"Android/Arquitectura/factory/#1-la-classe-concreta","title":"1. La Classe Concreta","text":"<p>El Factory amaga l'exist\u00e8ncia (i el nom) de les classes que implementen la interf\u00edcie del producte.</p> <ul> <li> <p>Sense Factory: El l'Activity hauria de fer:</p> <p><pre><code>val notification: AppNotification = SimpleNotification(data.text) // Necessita saber el nom exacte\n</code></pre> - Amb Factory: El l'Activity nom\u00e9s veu el tipus d'entrada (NotificationType) i el tipus de sortida (AppNotification). <pre><code>val notification: AppNotification = NotificationFactory.createNotification(type) // No coneix SimpleNotification\n</code></pre></p> </li> </ul>"},{"location":"Android/Arquitectura/factory/#2-la-logica-complexa-de-construccio","title":"2. La L\u00f2gica Complexa de Construcci\u00f3","text":"<p>l Factory s'utilitza per amagar tota la l\u00f2gica de configuraci\u00f3 interna necess\u00e0ria per construir la inst\u00e0ncia. - Sense Factory</p> <pre><code>```kotlin \n// El client s'ha de preocupar: \nval builder = NotificationCompat.Builder(context, CHANNEL_ID) \n    .setContentTitle(\"New message\") \n    .setContentText(data.text) \n    .setSmallIcon(R.drawable.ic_noti) // ... 10 l\u00ednies de configuraci\u00f3 m\u00e9s \n```kotlin\n</code></pre> <ul> <li>Amb Factory (L\u00f2gica oculta)     <pre><code>// El client nom\u00e9s subministra les dades:\nval notification = NotificationFactory.createNotification(type)\n</code></pre></li> </ul>"},{"location":"Android/Arquitectura/factory/#exemple-de-mes-ocultacio","title":"Exemple de M\u00e9s Ocultaci\u00f3","text":"<p>Imagina que el Factory rep nom\u00e9s les dades en brut (<code>MessageData</code>) i decideix internament.</p> <p>```kotlin data class MessageData(     val title: String,     val text: String,     val hasImage: Boolean,     val imageUrl: String? )</p> <p>object SmartNotificationFactory {     // El Factory rep DADES GEN\u00c8RIQUES, no un tipus de Producte pre-escollit.     fun createNotificationFromData(data: MessageData): AppNotification {         return if (data.hasImage) {             // El Factory decideix la classe i fa la instanciaci\u00f3             ImageNotification(data.imageUrl!!)          } else {             SimpleNotification(data.text)         }     } }</p>"},{"location":"Android/Arquitectura/inversiodependencies/","title":"Inversi\u00f3 de Depend\u00e8ncies","text":""},{"location":"Android/Arquitectura/inversiodependencies/#inversio-de-dependencies","title":"Inversi\u00f3 de depend\u00e8ncies:","text":"<p>Llegir el seguent article: </p>"},{"location":"Android/Arquitectura/observer/","title":"Observaci\u00f3 de LiveData des de la UI","text":""},{"location":"Android/Arquitectura/observer/#metode-observe-i-el-lifecycleowner","title":"M\u00e8tode observe() i el LifecycleOwner","text":"<p>El m\u00e8tode observe() \u00e9s la forma principal d'observar LiveData des dels components de UI. Requereix dos par\u00e0metres: un LifecycleOwner i un Observer.</p> <p>Signatura del m\u00e8tode: <pre><code>fun observe(owner: LifecycleOwner, observer: Observer&lt;T&gt;)\n</code></pre></p> <p>Components:</p> <ul> <li>LifecycleOwner: Component amb cicle de vida (Activity, Fragment)</li> <li>Observer: Lambda o classe que rep les actualitzacions</li> </ul> <p>A Activity: <pre><code>class MainActivity : AppCompatActivity() {\n    private val viewModel: DadesViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // 'this' \u00e9s el LifecycleOwner (Activity)\n        viewModel.dades.observe(this) { dades -&gt;\n            // Actualitzar UI amb les noves dades\n            textView.text = dades\n        }\n    }\n}\n</code></pre> A Fragment (IMPORTANT): <pre><code>class MeuFragment : Fragment() {\n    private val viewModel: DadesViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        //CORRECTE: usar viewLifecycleOwner\n        viewModel.dades.observe(viewLifecycleOwner) { dades -&gt;\n            textView.text = dades\n        }\n\n        //INCORRECTE: NO usar 'this' en Fragments\n        // viewModel.dades.observe(this) { ... }  // Pot causar memory leaks!\n    }\n}\n</code></pre> Per qu\u00e8 viewLifecycleOwner en Fragments:</p> <p>Els Fragments tenen DOS cicles de vida: el del Fragment i el de la View La View pot destruir-se i recrear-se mentre el Fragment segueix viu Usar this pot causar que l'observer segueixi actiu quan la View ja no existeix viewLifecycleOwner s'atura quan la View es destrueix, evitant memory leaks</p>"},{"location":"Android/Arquitectura/recyclerinversio/","title":"Exemple d'inversi\u00f3 de depend\u00e8ncies amb el Recycler view senzill","text":""},{"location":"Android/Arquitectura/recyclerinversio/#problema-de-callbacks","title":"Problema de callbacks:","text":"<p>Si examinem l'exemple de recyclerview tal i com est\u00e0, (passant funcions de callback), podem trobar els problemes seg\u00fcents:</p>"},{"location":"Android/Arquitectura/recyclerinversio/#1-memory-leaks","title":"1. Memory Leaks\u200b","text":"<ul> <li>La lambda f\u00e0 refer\u00e8ncia a l'activity( el this en el Toast)</li> <li>Si l'Activity es destrueix (rotaci\u00f3, backstack), per\u00f2 l'Adapter/ViewHolder segueix viu \u2192 leak.</li> <li>L'Activity no es pot recollir per garbage collector.</li> </ul>"},{"location":"Android/Arquitectura/recyclerinversio/#2-acoblament-fort","title":"2. Acoblament fort","text":"<ul> <li>L'Activity s'ha de con\u00e8ixer qu\u00e8 fa l'Adapter (passar callbacks espec\u00edfics).</li> <li>Dif\u00edcil reutilitzar l'Adapter en un altre context.</li> </ul>"},{"location":"Android/Arquitectura/recyclerinversio/#3-violacio-single-responsibility","title":"3. Violaci\u00f3 Single Responsibility","text":"<ul> <li>L'Activity fa 3 coses:</li> <li>Presenta UI</li> <li>Gestiona RecyclerView</li> <li>Gestiona negocis (qu\u00e8 fer al clic). Aix\u00f3 \u00faltim no ho hauria de fer. No \u00e9s la serva responsabilitat.</li> </ul>"},{"location":"Android/Arquitectura/recyclerinversio/#sollucio-amb-inversio-de-dependencies-dependency-inversion-principle-dip","title":"Sol\u00b7luci\u00f3 amb inversi\u00f3 de depend\u00e8ncies (Dependency Inversion Principle - DIP)","text":""},{"location":"Android/Arquitectura/recyclerinversio/#1-interficie-clara-i-tipada","title":"1. Interf\u00edcie clara i tipada","text":"<pre><code>interface ItemClickListener {\n    fun onItemClick(item: MyItem)\n}\n</code></pre>"},{"location":"Android/Arquitectura/recyclerinversio/#2-adapter-rep-interficie-no-lambda","title":"2. Adapter rep interf\u00edcie (NO lambda)","text":"<pre><code>class MyAdapter(\n    private val items: List&lt;MyItem&gt;,\n    private val listener: ItemClickListener  // \u2190 Millor!\n) : RecyclerView.Adapter&lt;MyViewHolder&gt;() {\n    // ... mateix codi\n}\n</code></pre>"},{"location":"Android/Arquitectura/recyclerinversio/#3-activity-nomes-implementa-interficie","title":"3. Activity nom\u00e9s implementa interf\u00edcie","text":"<pre><code>class MainActivity : AppCompatActivity(), ItemClickListener {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        adapter = MyAdapter(items, this)  // \u2190 Passa Activity com a listener\n        recyclerView.adapter = adapter\n    }\n\n    // L\u00f2gica de negoci AQU\u00cd, separada de UI\n    override fun onItemClick(item: MyItem) {\n        Toast.makeText(this, \"Clicat ${item.title}\", Toast.LENGTH_SHORT).show()\n        // O millor: cridar ViewModel\n        // viewModel.onItemSelected(item)\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/recyclerinversio/#que-diu-el-principi-dip","title":"Qu\u00e8 diu el principi DIP?\u200b","text":"<pre><code>\"Les m\u00f2duls d'alt nivell NO han de dependre de m\u00f2duls de baix nivell.\nAMBDOs han de dependre d'abstraccions (interf\u00edcies).\"\n</code></pre>"},{"location":"Android/Arquitectura/recyclerinversio/#en-el-nostre-cas","title":"En el nostre cas:","text":"<p><pre><code>- Incorrecte: Activity (alt nivell) \u2190 DEPEN de MyAdapter (baix nivell)\n- Correcte: Activity (alt nivell) \u2192 ItemClickListener \u2190 MyAdapter (baix nivell)\n</code></pre> Beneficis pr\u00e0ctics:</p> <ol> <li>L'Activity es pot canviar (Fragment, Compose Screen) sense tocar Adapter</li> <li>L'Adapter es pot reutilitzar en qualsevol Activity/Fragment</li> <li>No t\u00e9 memory leaks (no captura 'this' directament dins lambda)</li> <li>Testejable: mockejar ItemClickListener</li> </ol>"},{"location":"Android/Arquitectura/repositori/","title":"Capa repositori i dades","text":""},{"location":"Android/Arquitectura/repositori/#1-situacio-inicial","title":"1. Situaci\u00f3 inicial","text":"<p>Partint del codi relatiu al Recyclerview, veurem que t\u00e9 algunes mancances o dificultats. No respecta els principis de clean code, ni t\u00e9 cap arquitectura definida:</p>"},{"location":"Android/Arquitectura/repositori/#problemes-darquitectura","title":"Problemes d'arquitectura","text":"<p>Abs\u00e8ncia de separaci\u00f3 de capes:   La Activity accedeix directament a les dades (directament a la llista en mem\u00f2ria o atrav\u00e9s d'una API).Aix\u00f2 crea un acoblament fort i dificulta enormement el testing i el manteniment.</p> <p>DataSource com a singleton est\u00e0tic:  Qualsevol canvi en com s'obtenen les dades (API, base de dades local, etc.) requerir\u00e0 modificar directament la Activity, per\u00f2 tamb\u00e9 tots els llocs on s'utilitza.</p> <p>L\u00f2gica de negoci a la UI: La Activity est\u00e0 fent massa coses: configura el RecyclerView, gestiona el clic, i decideix qu\u00e8 mostrar (el Toast o ). No hi ha cap ViewModel ni cap capa interm\u00e8dia que gestioni l'estat o la l\u00f2gica.</p>"},{"location":"Android/Arquitectura/repositori/#problemes-que-pot-ocasionar","title":"Problemes que pot ocasionar","text":"<ul> <li>Escalabilitat nul\u00b7la: Quan el projecte creixi i necessitis m\u00faltiples fonts de dades, c\u00e0rrega as\u00edncrona, cach\u00e9, o sincronitzaci\u00f3, aquest codi ser\u00e0 molt dif\u00edcil de mantenir.</li> <li>Impossibilitat de testing autom\u00e0tic: Aquest codi fa els tests pr\u00e0cticament impossibles.</li> <li>Duplicaci\u00f3 de codi futura: Sense una arquitectura clara, cada nova funcionalitat similar acabar\u00e0 repetint patrons, copiant i enganxant codi.</li> </ul>"},{"location":"Android/Arquitectura/repositori/#2-analisi-codi-incorrectesense-separacio-de-capa","title":"2. An\u00e0lisi codi Incorrecte:(sense separaci\u00f3 de capa)","text":"<p>Item: Classe que cont\u00e9 les dades que necessitem (pot ser recepta, pelicula, reserva, itemcompra, ticket, etc..)</p> <pre><code>// Fitxer: MyItem.kt\ndata class MyItem(\n    val title: String,\n    val subtitle: String\n)\n</code></pre> <p>Datasource: Classe (objecte en aquest cas) que cont\u00e9 la llista d'items</p> <p><pre><code>// Fitxer: DataSource.kt\n\n/**\n * Objecte singleton que proporciona dades en mem\u00f2ria\n * per ser utilitzades al RecyclerView.\n */\nobject DataSource {\n\n    // Llista de dades en mem\u00f2ria (nom\u00e9s de lectura)\n    val items: List&lt;MyItem&gt; = listOf(\n        MyItem(\"Element 1\", \"Subt\u00edtol 1\"),\n        MyItem(\"Element 2\", \"Subt\u00edtol 2\"),\n        MyItem(\"Element 3\", \"Subt\u00edtol 3\"),\n        MyItem(\"Element 4\", \"Subt\u00edtol 4\")\n    )\n}\n</code></pre> Des de l'activity, es crea la llista d'items. Aix\u00f3 \u00e9s incorrecte doncs no \u00e9s la tasca de l'activity. <pre><code>        // 3. Crear llista de dades (des de DataSource o directament)\n        val items = DataSource.items\n</code></pre></p>"},{"location":"Android/Arquitectura/repositori/#objectiu-del-clean-clode-i-arquitectura-per-capes","title":"Objectiu del Clean Clode i arquitectura per capes","text":"<p>Hem de fer independent les dades de la implementaci\u00f3, perque la UI pugui cridar un m\u00e9tode  gen\u00e8ric. Per tant, ha de ser independent </p> <p>Aquesta classe s'anomena Repositori, i corresp\u00f3n a la Capa de domini</p>"},{"location":"Android/Arquitectura/repositori/#daquesta-manera-tindrem-3-capes","title":"D'aquesta manera, tindrem 3 capes:","text":"<ol> <li>UI (Activities, ViewModels)</li> <li>Domini (Repositori)</li> <li>Dades (Datasources amb Interface)</li> </ol> <p>Repository: Coordinador i font de dades. Recupera les dades, pero no directament, sin\u00f3 a trav\u00e9s dels datasources.</p> <p>Per exemple: <pre><code>class ItemsRepository(\n    private val dataSource: ItemsDataSource\n) {\n\n    fun getItems(): List&lt;MyItem&gt; {\n         dataSource.getItems()   \n    }\n}\n</code></pre></p> <p>Per qu\u00e8 necessites la capa de Domini (amb el Repositori)? Per diferents responsabilitats</p> <ul> <li>Repository: S'encarrega de la l\u00f2gica de negoci relacionada amb les dades:<ul> <li>Gesti\u00f3 de cach\u00e9</li> <li>Combinaci\u00f3 de m\u00faltiples fonts de dades (local + remota)</li> <li>Decisi\u00f3 de quan usar dades locals vs remotes</li> <li>Transformaci\u00f3 de dades entre capes</li> <li>Gesti\u00f3 d'errors i fallbacks</li> </ul> </li> <li>DataSource: S'encarrega NOM\u00c9S d'obtenir/guardar dades d'una font espec\u00edfica (mock, API, base de dades).</li> </ul>"},{"location":"Android/Arquitectura/repositori/#3-implementacio-correcte-amb-separacio-de-capes-uidominidades","title":"3. Implementaci\u00f3 correcte (amb separaci\u00f3 de capes UI,Domini,Dades)","text":""},{"location":"Android/Arquitectura/repositori/#capa-domini","title":"Capa Domini","text":"<p>(la classe repositori que hem vist abans), hi ha diferents maneres d'implementar-la i a m\u00e9s es poden afegir els casos d'\u00fas.</p> <pre><code>class ItemsRepository(\n    private val dataSource: ItemsDataSource\n) {\n\n    fun getItems(): List&lt;MyItem&gt; {\n         dataSource.getItems()   \n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/repositori/#capa-dades","title":"Capa Dades","text":"<p>Interface +  Datasources concrets.</p> <pre><code>interface ItemDataSource {\n   fun getItems(): List&lt;MyItem&gt;\n   fun addItem(item: MyItem)\n   fun updateItem(item: MyItem)\n   fun deleteItem(item: MyItem)\n}\n</code></pre> <p>I ara podem crear m\u00faltiples datasources, amb implementacions diferents (Mock, api, bbdd)</p> <p>Qu\u00e8 \u00e9s Mock?</p> <p>Mock es refereix a dades falses, i s'utilitza en programaci\u00f3 per provar les classes abans no es tingui una base de dades, api, etc. En aquest cas, el MockItemDataSource \u00e9s una llista precodificada (com hav\u00edem fet abans en el nostre object Datasource)</p> <pre><code>class MockItemDataSource : ItemDataSource {\n   private val items = mutableListOf(\n       MyItem(1, \"Element A\"),\n       MyItem(2, \"Element B\"),\n       MyItem(3, \"Element C\")\n   )\n   override fun getItems(): List&lt;MyItem&gt; = items\n   override fun addItem(item: MyItem) { items.add(item) }\n   override fun updateItem(item: MyItem) {//implementacio  }\n   override fun deleteItem(item: MyItem) {//implementacio }\n}\n\n\nclass RetrofitItemDataSource : ItemDataSource {\n   override fun getItems(): List&lt;MyItem&gt; { ... }\n   override fun addItem(item: MyItem) { ... }\n   override fun updateItem(item: MyItem) { ... }\n   override fun deleteItem(item: MyItem) {\n       RetrofitClient.instance.deleteItem(item.id).execute()\n   }\n}\n</code></pre> <p>D'aquesta manera el Repositori no necessita saber com estan implementades (com s'aconsegueixen, es guarden, etc) les dades.</p> <p>Ara podem fer f\u00e0cilment un  <pre><code>val ItemDataSource = if (\u201cTesting\u201d) {\n        CreateMockItemDataSource()\n    } else {\n        CreateRetrofitItemDataSource()\n    }\n\nval itemRepository = ItemRepository(ItemDataSource)\n\n//i ja es pot fer additem independentment de si es testing o si es api, room, etc\u2026\nitemRepository.addItem(newitem)\n</code></pre> Es poden crear altres datasources per coses diferents, per\u00f2 el repositori no t\u00e9 acc\u00e9s a les dades, ho fa a trav\u00e9s del interface.</p>"},{"location":"Android/Arquitectura/repositori/#4-explicacio-capes","title":"4. Explicaci\u00f3 capes","text":"<p>Aquestes s\u00f3n les capes que han intervingut:</p> <p></p> <ul> <li>Presentation (UI) Layer: ViewModel, estats UI i la Activity</li> <li>Domain Layer: Cont\u00e9 l'entitat Item, el contracte ItemRepository i els Use Cases per a cada operaci\u00f3 CRUD. Els Use Cases els explicarem en un altre apartat.</li> <li>Data Layer: Implementa el repository i datasources. Cont\u00e9 l'entitat de base de dades, DAO (si n'hi ha).</li> </ul> <p>Dins el DataLayer: { align=left style=\"height: 30%; width: 30%; border-radius: 5px;\" loading=lazy}</p>"},{"location":"Android/Arquitectura/repositori/#principis-de-clean-code-aplicats","title":"Principis de Clean Code aplicats:","text":"<ul> <li>Single Responsibility: Cada classe t\u00e9 una \u00fanica responsabilitat</li> <li>Dependency Inversion: Les capes superiors no depenen de les inferiors directament</li> <li>Separation of Concerns: Cada capa t\u00e9 la seva responsabilitat ben definida</li> </ul> <p>Info</p> <p>El Domain Layer \u00e9s el nucli de l'aplicaci\u00f3 i roman estable independentment de com implementis la persist\u00e8ncia o la presentaci\u00f3. Aix\u00f2 \u00e9s el que fa que l'arquitectura sigui tan robusta i mantenible.</p>"},{"location":"Android/Arquitectura/repositori/#esquema-general","title":"Esquema general:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   PRESENTATION      \u2502  \u2190 Dep\u00e8n del Domain\n\u2502  (Activity/Fragment)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502 dep\u00e8n de (a trav\u00e9s dels casos d\u2019\u00fas o repositori)\n           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     DOMAIN          \u2502  \u2190 INDEPENDENT (no dep\u00e8n de res)\n\u2502   (Use Cases)       \u2502    Defineix contractes (interfaces)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    i els casos d\u2019us\n           \u2502 implementa\n           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      DATA           \u2502  \u2190 Dep\u00e8n del Domain (implementa les interfaces)\n\u2502  (Repository Impl)  \u2502    a trav\u00e9s de la inversi\u00f3 de depend\u00e8ncies.\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Info</p> <p>Veure apartat d'inversi\u00f3 de depend\u00e8ncies</p> <p>Info</p> <p>Veure exemple implementaci\u00f3 RecyclerView amb inversi\u00f3 de depend\u00e8ncies (Exemple DIP recycler)</p>"},{"location":"Android/Arquitectura/solid/","title":"Principis SOLID","text":""},{"location":"Android/Arquitectura/solid/#principis-solid","title":"Principis SOLID","text":"<p>Llegir el seg\u00fcent document:</p> <p>https://devexpert.io/blog/principios-solid</p>"},{"location":"Android/Arquitectura/viewmodel/","title":"Viewmodel","text":"<p>Documentaci\u00f3 oficial: https://developer.android.com/topic/libraries/architecture/viewmodel</p>"},{"location":"Android/Arquitectura/viewmodel/#informacio-viewmodel-i-livedata","title":"Informaci\u00f3 Viewmodel i livedata","text":"<p>View model \u00e9s una arquitectura que permet separar la l\u00f2gica de la activity, de l'activity mateixa.</p> <p>La separaci\u00f3 \u00e9s important, perque s'ent\u00e9n que una activity no hauria de saber (no s'hi hauria d'implementar) quines dades </p>"},{"location":"Android/Arquitectura/viewmodel/#1-conceptes-basics","title":"1-Conceptes b\u00e0sics","text":""},{"location":"Android/Arquitectura/viewmodel/#que-es-i-per-que-existeix-separacio-de-logica-i-ui","title":"Qu\u00e8 \u00e9s i per qu\u00e8 existeix (separaci\u00f3 de l\u00f2gica i UI)","text":"<p>El ViewModel \u00e9s un component d'arquitectura dissenyat per emmagatzemar i gestionar dades relacionades amb la UI de manera conscient del cicle de vida. Per qu\u00e8 existeix:</p> <ul> <li>Separaci\u00f3 de responsabilitats: La l\u00f2gica de negoci i les dades estan separades de la UI (Activity/Fragment) -Testabilitat: Pots testejar la l\u00f2gica sense necessitat de components d'Android</li> <li>Reutilitzaci\u00f3: Diversos Fragments poden compartir el mateix ViewModel</li> <li>Persist\u00e8ncia: Les dades sobreviuen a canvis de configuraci\u00f3</li> </ul>"},{"location":"Android/Arquitectura/viewmodel/#sense-viewmodel","title":"Sense ViewModel:","text":"<pre><code>class MainActivity : AppCompatActivity() {\n    private var counter = 0 // Es perd en rotar la pantalla\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // L\u00f2gica barrejada amb codi de UI\n        button.setOnClickListener {\n            counter++\n            textView.text = counter.toString()\n            // Crides a API, c\u00e0lculs, etc...\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#amb-viewmodel","title":"Amb ViewModel:","text":"<pre><code>class CounterViewModel : ViewModel() {\n    private val _counter = MutableLiveData(0)\n    val counter: LiveData&lt;Int&gt; = _counter\n\n    fun increment() {\n        _counter.value = (_counter.value ?: 0) + 1\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: CounterViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        viewModel.counter.observe(this) { count -&gt;\n            textView.text = count.toString()\n        }\n\n        button.setOnClickListener {\n            viewModel.increment()\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#cicle-de-vida-del-viewmodel-vs-activityfragment","title":"Cicle de vida del ViewModel vs Activity/Fragment","text":"<p>El ViewModel t\u00e9 un cicle de vida diferent i m\u00e9s llarg que l'Activity o Fragment que l'utilitza.</p> <p>Cicle de vida: <pre><code>ActivityCreatedDestroyed (rotation) \u2192 Re-created \u2192 Finished\n    \u2502                    \u2502                \u2502            \u2502\n    \u25bc                    \u2502                \u2502            \u25bc\nViewModel Created        \u2502                \u2502        onCleared()\n    \u2502                    \u2502                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         (ViewModel es mant\u00e9 viu)\n</code></pre> Exemple pr\u00e0ctic: <pre><code>class MyViewModel : ViewModel() {\n    init {\n        Log.d(\"ViewModel\", \"ViewModel creat\")\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        Log.d(\"ViewModel\", \"ViewModel destru\u00eft\")\n        // Neteja recursos: cancel\u00b7lar coroutines, tancar connexions, etc.\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: MyViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        Log.d(\"Activity\", \"onCreate\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"Activity\", \"onDestroy\")\n    }\n}\n</code></pre></p> <p>Logs en rotar la pantalla: <pre><code>ViewModel creat\nActivity onCreate\nActivity onDestroy (rotaci\u00f3)\nActivity onCreate (nova inst\u00e0ncia)\n// ViewModel segueix viu!\n\n// Nom\u00e9s quan tanquem l'Activity:\nActivity onDestroy\nViewModel destru\u00eft\n</code></pre></p>"},{"location":"Android/Arquitectura/viewmodel/#supervivencia-a-canvis-de-configuracio-rotacions","title":"Superviv\u00e8ncia a canvis de configuraci\u00f3 (rotacions)","text":"<p>El ViewModel sobreviu autom\u00e0ticament a canvis de configuraci\u00f3 com rotacions, canvis d'idioma, etc.</p> <p>El problema sense ViewModel: <pre><code>class MainActivity : AppCompatActivity() {\n    private var userData: User? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Cada cop que rotes, has de tornar a carregar les dades\n        // i si s'han modificat, es perden les modificacions\n        userData=loadUserData() // Crida a l'API, base de dades...\n\n    }\n}\n</code></pre></p> <p>La soluci\u00f3 amb ViewModel: <pre><code>class UserViewModel : ViewModel() {\n    private val _userData = MutableLiveData&lt;User&gt;()\n    val userData: LiveData&lt;User&gt; = _userData\n\n    init {\n        loadUserData() // Nom\u00e9s es crida UNA vegada\n    }\n\n    //loadUserData obt\u00e9 l'usuari de una bbdd, api, etc..\n    private fun loadUserData() {\n        //obtenir l'usuari de manera as\u00edncronta (veure corrutines)\n        viewModelScope.launch {\n            _userData.value = \"Usuari1\"\n        }\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Les dades ja estan disponibles despr\u00e9s de rotar\n        viewModel.userData.observe(this) { user -&gt;\n            textView.text = user.name\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Arquitectura/viewmodel/#2-ambits-scopes","title":"2-\u00c0mbits (Scopes)","text":""},{"location":"Android/Arquitectura/viewmodel/#viewmodel-no-compartit-viewmodels","title":"ViewModel no compartit (viewModels())","text":"<p>Cada Activity o Fragment t\u00e9 la seva pr\u00f2pia inst\u00e0ncia del ViewModel. \u00c0mbit d'Activity: <pre><code>class MainActivity : AppCompatActivity() {\n    // ViewModel amb \u00e0mbit d'aquesta Activity\n    private val viewModel: MyViewModel by viewModels()\n}\n\nclass OtherActivity : AppCompatActivity() {\n    // Inst\u00e0ncia DIFERENT del mateix ViewModel\n    private val viewModel: MyViewModel by viewModels()\n}\n</code></pre></p> <p>\u00c0mbit de Fragment: <pre><code>class FirstFragment : Fragment() {\n    // ViewModel amb \u00e0mbit d'aquest Fragment\n    private val viewModel: MyViewModel by viewModels()\n}\n\nclass SecondFragment : Fragment() {\n    // Inst\u00e0ncia DIFERENT, incl\u00fas si estan a la mateixa Activity\n    private val viewModel: MyViewModel by viewModels()\n}\n</code></pre></p> <p>Quan utilitzar-ho:</p> <ul> <li>Dades espec\u00edfiques d'una \u00fanica pantalla</li> <li>No necessites compartir informaci\u00f3 entre components</li> <li>L\u00f2gica a\u00efllada d'un sol Fragment</li> </ul>"},{"location":"Android/Arquitectura/viewmodel/#viewmodel-compartit-activityviewmodels","title":"ViewModel compartit (activityViewModels())","text":"<p>Diversos Fragments dins de la mateixa Activity poden accedir a la mateixa inst\u00e0ncia del ViewModel.</p> <p>Exemple de comunicaci\u00f3 entre Fragments: <pre><code>class SharedViewModel : ViewModel() {\n    private val _selectedItem = MutableLiveData&lt;Item&gt;()\n    val selectedItem: LiveData&lt;Item&gt; = _selectedItem\n\n    fun selectItem(item: Item) {\n        _selectedItem.value = item\n    }\n}\n\nclass ListFragment : Fragment() {\n    // Obt\u00e9 el ViewModel de l'Activity pare\n    private val sharedViewModel: SharedViewModel by activityViewModels()\n\n    private fun onItemClicked(item: Item) {\n        sharedViewModel.selectItem(item)\n    }\n}\n\nclass DetailFragment : Fragment() {\n    // La MATEIXA inst\u00e0ncia del ViewModel\n    private val sharedViewModel: SharedViewModel by activityViewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        sharedViewModel.selectedItem.observe(viewLifecycleOwner) { item -&gt;\n            // Mostra els detalls de l'item seleccionat\n            textView.text = item.name\n        }\n    }\n}\n</code></pre></p> <p>Quan utilitzar-ho:</p> <ul> <li>Comunicaci\u00f3 entre Fragments</li> <li>Compartir estat dins d'una Activity</li> <li>Navegaci\u00f3 amb dades (passar informaci\u00f3 entre pantalles)</li> <li>Patr\u00f3 Master-detail</li> </ul>"},{"location":"Android/Arquitectura/viewmodel/#resum","title":"Resum:","text":"Delegat On s'utilitza \u00c0mbit de Cicle de Vida Prop\u00f2sit principal by viewModels() Fragment o ComponentActivity Lligat al cicle de vida de la Fragment o Activity actual. ViewModel local per a una sola pantalla (Fragment o Activity). by activityViewModels() Fragment (nom\u00e9s) Lligat al cicle de vida de l'Activity que cont\u00e9 el Fragment. Compartir dades i l\u00f2gica entre m\u00faltiples Fragments dins de la mateixa Activity. by viewModel() ComponentActivity (o Activity en general) Lligat al cicle de vida de l'Activity actual. ViewModel local per a una sola Activity. (\u00c9s l'equivalent de by viewModels() utilitzat en una Activity)."},{"location":"Android/Arquitectura/viewmodel/#3-viewmodelprovider-i-factories","title":"3-ViewModelProvider i Factories","text":"<p>Quan el ViewModel necessita par\u00e0metres al constructor, \u00e9s necessari implementar un patr\u00f3 factory, per poder passar les dades. Es fa aix\u00ed:</p> <p>ViewModel amb par\u00e0metres: <pre><code>class UserViewModel(\n    private val userId: String,\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _user = MutableLiveData&lt;User&gt;()\n    val user: LiveData&lt;User&gt; = _user\n\n    init {\n        loadUser()\n    }\n\n    private fun loadUser() {\n        viewModelScope.launch {\n            _user.value = repository.getUser(userId)\n        }\n    }\n}\n</code></pre></p> <p>Crear un Factory: <pre><code>class UserViewModelFactory(\n    private val userId: String,\n    private val repository: UserRepository\n) : ViewModelProvider.Factory {\n\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(UserViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return UserViewModel(userId, repository) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre> Utilitzar el Factory: <pre><code>class UserActivity : AppCompatActivity() {\n\n    private val viewModel: UserViewModel by viewModels {\n        UserViewModelFactory(\n            userId = intent.getStringExtra(\"USER_ID\") ?: \"\",\n            repository = UserRepository()\n        )\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        viewModel.user.observe(this) { user -&gt;\n            textView.text = user.name\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Arquitectura/viewmodel/#4-recursos","title":"4. Recursos","text":"<p>https://www.youtube.com/watch?v=orH4K6qBzvE</p>"},{"location":"Android/Firebase/","title":"Firebase","text":"<p>Continguts:</p> <ul> <li>Setup de Firebase a Android: Android/Firebase/fbsetup.md</li> <li>Autenticaci\u00f3: (Pendent)</li> <li>Firestore:  (Pendent)</li> <li>Storage:  (Pendent)</li> <li>FireCloud Messaging:  (Pendent)</li> </ul>"},{"location":"Android/Firebase/#les-eines-de-firebase-es-poden-dividir-en-4-blocs-principals","title":"Les eines de Firebase es poden dividir en 4 blocs principals:","text":""},{"location":"Android/Firebase/#1-back-end-en-temps-real-les-mes-importants","title":"1. Back-end en temps real (les m\u00e9s importants)","text":""},{"location":"Android/Firebase/#firestore-base-de-dades-nosql-en-temps-real","title":"Firestore (Base de dades NoSQL en temps real)","text":"<p>La m\u00e9s potent i f\u00e0cil per a apps m\u00f2bils.</p> <p>Emmagatzema documents i col\u00b7leccions (JSON)</p> <p>Actualitza autom\u00e0ticament la UI quan hi ha canvis</p> <p>Permet consultes (filters, orders)</p> <p>Funciona offline</p> <p>Permet permisos basats en usuari (rules)</p>"},{"location":"Android/Firebase/#projectes-tipics","title":"Projectes t\u00edpics:","text":"<p>Xat en temps real</p> <p>Notes/fites compartides</p> <p>CRUD complet sense backend propi</p> <p>Llistes sincronitzades amb RecyclerView</p>"},{"location":"Android/Firebase/#realtime-database","title":"Realtime Database","text":"<p>La base de dades cl\u00e0ssica de Firebase.</p> <p>Tamb\u00e9 en temps real</p> <p>M\u00e9s senzilla per\u00f2 menys flexible que Firestore</p>"},{"location":"Android/Firebase/#projectes","title":"Projectes:","text":"<p>CRUD molt simple, jocs o apps col\u00b7laboratives.</p>"},{"location":"Android/Firebase/#2-autenticacio-i-seguretat","title":"2. Autenticaci\u00f3 i seguretat","text":""},{"location":"Android/Firebase/#firebase-authentication-imprescindible","title":"Firebase Authentication (imprescindible)","text":"<p>Manera f\u00e0cil i moderna d\u2019autenticar usuaris:</p> <p>Correu + contrasenya</p> <p>Google, Facebook, Apple</p> <p>An\u00f2nim</p> <p>Enviament de correus de verificaci\u00f3</p>"},{"location":"Android/Firebase/#perfeta-per","title":"Perfeta per:","text":"<p>Login + registre complet en 15 minuts, sense backend.</p>"},{"location":"Android/Firebase/#cloud-firestore-security-rules","title":"Cloud Firestore Security Rules","text":"<p>Sistema per definir permisos:</p> <p>Qui pot llegir?</p> <p>Qui pot escriure?</p> <p>Condicions basades en usuari?</p>"},{"location":"Android/Firebase/#projectes_1","title":"Projectes:","text":"<p>Apps multi-usuari segures sense servidor.</p>"},{"location":"Android/Firebase/#3-comunicacio-i-notificacions","title":"3. Comunicaci\u00f3 i notificacions","text":""},{"location":"Android/Firebase/#firebase-cloud-messaging-fcm","title":"Firebase Cloud Messaging (FCM)","text":"<p>Servei professional per a notificacions push.</p> <p>Enviar notificacions a dispositius Android</p> <p>Des de consola o backend</p> <p>Personalitzaci\u00f3 per topic (\u201cnovetats\u201d, \u201cpromocions\u201d\u2026)</p> <p>Rebre notificacions en segon pla</p>"},{"location":"Android/Firebase/#perfecte-per","title":"Perfecte per:","text":"<p>Enviar avisos a moda de \u201cbackend real\u201d.</p>"},{"location":"Android/Firebase/#4-eines-complementaries-molt-utils-segons-el-projecte","title":"4. Eines complement\u00e0ries (molt \u00fatils segons el projecte)","text":""},{"location":"Android/Firebase/#firebase-storage","title":"Firebase Storage","text":"<p>Emmagatzemament d\u2019arxius:</p> <p>Imatges</p> <p>PDFs</p> <p>Audios</p> <p>V\u00eddeos</p>"},{"location":"Android/Firebase/#projectes_2","title":"Projectes:","text":"<p>Perfil d\u2019usuari amb foto, pujar documents.</p>"},{"location":"Android/Firebase/#firebase-analytics","title":"Firebase Analytics","text":"<p>Anal\u00edtica integrada:</p> <p>Pantalles visitades</p> <p>Temps en cada vista</p> <p>Esdeveniments personalitzats</p>"},{"location":"Android/Firebase/#recomanacio-el-pac-de-4-imprescindible","title":"RECOMANACI\u00d3: El \u201cPac de 4\u201d imprescindible","text":"<p>Per a projectes, els quatre serveis m\u00e9s rellevants i aplicables s\u00f3n:</p>"},{"location":"Android/Firebase/#1-firebase-authentication","title":"1. Firebase Authentication","text":"<ul> <li>login i registre sense servidor.</li> </ul>"},{"location":"Android/Firebase/#2-firebase-firestore","title":"2. Firebase Firestore","text":"<ul> <li>CRUD en temps real i sincronitzaci\u00f3 autom\u00e0tica.</li> </ul>"},{"location":"Android/Firebase/#3-firebase-cloud-messaging-fcm","title":"3. Firebase Cloud Messaging (FCM)","text":"<ul> <li>notificacions push reals.</li> </ul>"},{"location":"Android/Firebase/#4-firebase-storage","title":"4. Firebase Storage","text":"<ul> <li>pujar i descarregar imatges.</li> </ul>"},{"location":"Android/Firebase/#amb-sols-aquests-4-els-alumnes-poden-construir","title":"Amb sols aquests 4, els alumnes poden construir:","text":"<ul> <li> <p>Una xarxa social b\u00e0sica</p> </li> <li> <p>App de xat</p> </li> <li> <p>Gestor de tasques multiusuari</p> </li> <li> <p>Aplicaci\u00f3 de not\u00edcies amb notificacions push</p> </li> <li> <p>App amb perfils d\u2019usuari i fotos</p> </li> <li> <p>Qualsevol CRUD sincronitzat i multi-dispositiu</p> </li> </ul>"},{"location":"Android/Firebase/fbsetup/","title":"Setup de Firebase a Android","text":""},{"location":"Android/Firebase/fbsetup/#1-crear-un-projecte-a-la-consola-de-firebase","title":"1. Crear un projecte a la consola de Firebase","text":"<ol> <li>Accedeix a Firebase Console</li> <li>Fes clic a \u201cAdd project\u201d (Afegir projecte).</li> <li>Introdueix el nom del projecte.</li> <li>(Opcional) Pots activar Google Analytics, per\u00f2 no \u00e9s necessari per comen\u00e7ar.</li> <li>Fes clic a \u201cCreate project\u201d i espera que Firebase finalitzi la creaci\u00f3 del projecte.</li> </ol>"},{"location":"Android/Firebase/fbsetup/#2-afegir-una-aplicacio-android-al-projecte-firebase","title":"2. Afegir una aplicaci\u00f3 Android al projecte Firebase","text":"<ol> <li> <p>A la vista del projecte a Firebase, fes clic a Android icon (\u201cAdd app\u201d).</p> </li> <li> <p>Introdueix el nom del paquet de la teva app Android (exactament el que tens a AndroidManifest.xml).</p> </li> <li> <p>(Opcional) Pots afegir un nickname de l\u2019aplicaci\u00f3 i el SHA-1 del certificat de depuraci\u00f3, si m\u00e9s endavant vols usar autenticaci\u00f3 o notificacions.</p> </li> </ol> <p>Fes clic a \u201cRegister app\u201d.</p>"},{"location":"Android/Firebase/fbsetup/#3-descarregar-el-fitxer-google-servicesjson","title":"3. Descarregar el fitxer google-services.json","text":"<ol> <li> <p>Despr\u00e9s de registrar l\u2019app, Firebase et donar\u00e0 un fitxer google-services.json.</p> </li> <li> <p>Descarrega aquest fitxer.</p> </li> <li> <p>Col\u00b7loca\u2019l a la carpeta app/ del teu projecte Android (no a la carpeta arrel del projecte).</p> </li> </ol> <pre><code>Important: No afegeixis aquest fitxer al repositori p\u00fablic de GitHub si cont\u00e9 credencials sensibles. Si \u00e9s p\u00fablic, considera utilitzar [GitHub Secrets] o ignorar-lo amb .gitignore.\n</code></pre>"},{"location":"Android/Firebase/fbsetup/#4-configuracio-del-projecte-a-android-studio","title":"4. Configuraci\u00f3 del projecte a Android Studio","text":"<p>Firebase utilitza el plugin de Google Services. Haur\u00e0s d\u2019afegir-lo al projecte.</p>"},{"location":"Android/Firebase/fbsetup/#pas-1-afegir-els-repositoris-i-dependencies-a-buildgradle-project-level","title":"Pas 1: Afegir els repositoris i depend\u00e8ncies a build.gradle (Project-level)","text":"<pre><code>buildscript {\n    repositories {\n        google()  // Necessari per Firebase\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:8.1.0\"  // Versi\u00f3 d\u2019exemple\n        classpath \"com.google.gms:google-services:4.4.0\"   // Plugin de Google Services\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n</code></pre>"},{"location":"Android/Firebase/fbsetup/#pas-2-aplicar-el-plugin-a-buildgradle-app-level","title":"Pas 2: Aplicar el plugin a build.gradle (App-level)","text":"<p>A app/build.gradle:</p> <pre><code>plugins {\n    id 'com.android.application'\n    id 'com.google.gms.google-services'  // Firebase plugin\n}\n</code></pre>"},{"location":"Android/Firebase/fbsetup/#pas-3-afegir-dependencies-especifiques-opcional-ara","title":"Pas 3: Afegir depend\u00e8ncies espec\u00edfiques (opcional ara)","text":"<p>Quan utilitzem algun dels serveis concrets de firebase, afegirem algunes depend\u00e8ncies. Aix\u00f2 estar\u00e0 explicat en el cap\u00edtol corresponent al servei.</p>"},{"location":"Android/Firebase/fbsetup/#5-sincronitzacio-del-projecte-amb-gradle","title":"5. Sincronitzaci\u00f3 del projecte amb Gradle","text":"<p>A Android Studio, fes clic a \u201cSync Now\u201d quan t\u2019aparegui la notificaci\u00f3.</p> <p>Assegura\u2019t que no hi ha errors. Si hi ha problemes amb repositoris o versions, comprova que google() est\u00e0 incl\u00f2s.</p>"},{"location":"Android/Firebase/fbsetup/#6-integracio-amb-github","title":"6. Integraci\u00f3 amb GitHub","text":"<p>Si el projecte est\u00e0 a GitHub, tingues en compte:</p> <p>Afegir google-services.json a .gitignore per evitar exposar credencials</p> <pre><code># Firebase config\n/app/google-services.json\n</code></pre> <p>Si treballes en equip, cada desenvolupador hauria de descarregar el seu fitxer google-services.json des de Firebase i col\u00b7locar-lo a app/.</p> <p>El fitxer build.gradle i la configuraci\u00f3 del plugin es poden versionar sense problemes.</p>"},{"location":"Android/Firebase/fbsetup/#7-verificar-la-integracio","title":"7. Verificar la integraci\u00f3","text":"<p>Tot i que encara no hem configurat cap servei concret, la millor manera de comprovar que el setup funciona \u00e9s sincronitzar i compilar el projecte. Si no hi ha errors relacionats amb Firebase, la configuraci\u00f3 \u00e9s correcta.</p>"},{"location":"Android/Firebase/fbsetup/#8-resum-dels-passos","title":"8. Resum dels passos:","text":"<pre><code>1. Crear projecte a Firebase Console\n   \u251c\u2500 Accedir a: https://console.firebase.google.com/\n   \u251c\u2500 \"Add project\"\n   \u251c\u2500 Nom del projecte\n   \u2514\u2500 (Opcional) Activar Google Analytics\n\n2. Afegir aplicaci\u00f3 Android al projecte Firebase\n   \u251c\u2500 Cliquer sobre el logo Android \"Add app\"\n   \u251c\u2500 Introduir el nom del paquet (package name)\n   \u251c\u2500 (Opcional) Nickname i SHA-1\n   \u2514\u2500 \"Register app\"\n\n3. Descarregar fitxer google-services.json\n   \u251c\u2500 Guardar-lo a la carpeta: app/\n   \u2514\u2500 \u26a0\ufe0f No pujar-lo a repositoris p\u00fablics\n\n4. Configuraci\u00f3 del projecte a Android Studio\n   \u251c\u2500 build.gradle (Project-level):\n   \u2502   \u251c\u2500 Afegir repositoris: google(), mavenCentral()\n   \u2502   \u2514\u2500 Afegir classpath: com.google.gms:google-services\n   \u251c\u2500 build.gradle (App-level):\n   \u2502   \u2514\u2500 Aplicar plugin: id 'com.google.gms.google-services'\n   \u2514\u2500 (Opcional) Afegir depend\u00e8ncies Firebase\n\n5. Sincronitzaci\u00f3 amb Gradle\n   \u2514\u2500 \"Sync Now\" \u2192 verificar que no hi hagi errors\n\n6. Integraci\u00f3 amb GitHub\n   \u251c\u2500 Afegir google-services.json a .gitignore\n   \u251c\u2500 Cada desenvolupador descarrega el seu google-services.json\n   \u2514\u2500 Versionar build.gradle i plugins sense problemes\n\n7. Verificaci\u00f3\n   \u2514\u2500 Compilar projecte \u2192 si no hi ha errors, configuraci\u00f3 correcta\n</code></pre>"},{"location":"Android/Interficies/","title":"Interf\u00edcies i components","text":""},{"location":"Android/Interficies/#continguts","title":"Continguts","text":"<ul> <li>Layouts:</li> <li>Temes i Estils:</li> <li>VieweBinding: </li> <li>Appbar:</li> <li>Toolbar:</li> <li>Bottom Menu:</li> <li>Navigation Drawer:</li> <li>Dialegs:</li> <li>RecyclerView:</li> <li>Recyclerview filtrat:</li> <li>Men\u00fas:</li> <li>Splash Screen:</li> <li>Voice Recognition:</li> </ul>"},{"location":"Android/Interficies/appbar/","title":"Appbar","text":"<p>Documentaci\u00f3 oficial: https://developer.android.com/develop/ui/views/components/appbar</p>"},{"location":"Android/Interficies/appbar/#1-concepte-i-funcio","title":"1. Concepte i funci\u00f3","text":"<p>Originalment coneguda com a Action Bar, aquesta barra estava estretament lligada a la tem\u00e0tica de l'activitat.  Va ser la soluci\u00f3 est\u00e0ndard per a la barra d'aplicacions abans de la introducci\u00f3 del widget Toolbar (introdu\u00eft formalment a Android 5.0 Lollipop i el Support Library).</p> <p>Amb l'arribada de Material Design, es va evolucionar al component Toolbar, oferint molta m\u00e9s flexibilitat en estil, posicionament i funcionalitats. Avui, quan parlem d'AppBar, generalment ens referim a una Toolbar configurada a la part superior de la pantalla.</p> <p>En aquest tema nom\u00e9s parlarem de la appbar predefinida pel sistema. Si es vol personalitzar, s'ha d'utilitzar una toolbar.</p> <p>La Appbar no s'ha de confondre amb la status bar.</p> Status bar Appbar"},{"location":"Android/Interficies/appbar/#limitacions","title":"Limitacions","text":"<p>La ra\u00f3 principal per la qual es va promoure la Toolbar \u00e9s la falta de flexibilitat de l'Action Bar per defecte.</p> Caracter\u00edstica Action Bar (Per Defecte) Toolbar (Widget Manual) Posicionament Sempre fixada a la part superior de la finestra de l'Activity. Es pot col\u00b7locar a qualsevol lloc del disseny (part inferior, central, etc.). Integraci\u00f3 amb Scroll No es coordina amb el contingut despla\u00e7able (no es pot col\u00b7lapsar). Integraci\u00f3 nativa amb CoordinatorLayout per a efectes de col\u00b7lapsament. Contingut Personalitzat Molt limitat. Nom\u00e9s permet canviar el text/icona. Es poden afegir widgets personalitzats (camps de cerca, imatges, etc.) directament al seu XML. Gesti\u00f3 Gestionada per la finestra de l'Activity (M\u00e8tode getSupportActionBar()). Gestionada com qualsevol altre widget de vista (findViewById())."},{"location":"Android/Interficies/appbar/#rols-principals","title":"Rols Principals:","text":"<ul> <li> <p>Identitat: Mostrar el nom de l'aplicaci\u00f3 o de la vista actual (T\u00edtol).</p> </li> <li> <p>Navegaci\u00f3: Oferir un mitj\u00e0 per moure's cap enrere o accedir a un calaix de navegaci\u00f3 (Navigation Icon).</p> </li> <li> <p>Accions: Proporcionar acc\u00e9s r\u00e0pid a les accions m\u00e9s importants del context actual (Action Menu).</p> </li> </ul>"},{"location":"Android/Interficies/appbar/#2-implementacio","title":"2. Implementaci\u00f3","text":"<p>L'Action Bar no es declara al fitxer XML del layout. La seva pres\u00e8ncia i estil es controlen exclusivament a trav\u00e9s del Tema de l'aplicaci\u00f3.</p> <p>Requisit de Tema: Per defecte, si el vostre tema hereta d'un tema que inclou una Action Bar (com ara Theme.AppCompat.Light.DarkActionBar), el sistema la dibuixar\u00e0 autom\u00e0ticament a la part superior de l'activitat.</p> <p>Temes Sense Barra: Si voleu eliminar-la (per exemple, per substituir-la per una Toolbar personalitzada), cal utilitzar un tema \"Sense Action Bar\", com ara:</p> <p>Theme.AppCompat.NoActionBar</p> <p>Theme.MaterialComponents.Light.NoActionBar</p> <p>Per accedir a la appbar si es configura a trav\u00e9s del tema, podem obtenir una refer\u00e8ncia aix\u00ed:</p> <pre><code>var toolbar= this.supportActionBar\n</code></pre>"},{"location":"Android/Interficies/appbar/#3-gestio-de-menus-igual-que-la-toolbar","title":"3. Gesti\u00f3 de Men\u00fas (Igual que la Toolbar)","text":"<p>En aquest aspecte, l'Action Bar es comporta de manera id\u00e8ntica a la Toolbar:</p> <p>Inflament del Men\u00fa: El contingut de les accions es defineix en un fitxer XML de men\u00fa i s'infla mitjan\u00e7ant el m\u00e8tode onCreateOptionsMenu(). <pre><code>override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n    menuInflater.inflate(R.menu.main_menu, menu)\n    return true\n}\n</code></pre></p> <p>Gesti\u00f3 de Clics: La l\u00f2gica del clic continua estant en onOptionsItemSelected(), on es gestionen tant les accions del men\u00fa com la fletxa \"Amunt\" (android.R.id.home). <pre><code>override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        // Obtenim l'identificador de l'\u00edtem clicat\n        return when (item.itemId) {\n            ...\n        }\n}\n</code></pre> Gesti\u00f3 dels elements del men\u00fa:</p> <p>Quan l'usuari fa click i s'ha de mostrar el men\u00fa, podem aprofitar per habilitar o deshabilitar algun element.  <pre><code>//Quan l'usuari fa click\noverride fun onPrepareOptionsMenu(menu: Menu?): Boolean {\n    if (true){\n        var item=menu?.findItem(R.id.profile_nav_home)\n       item?.setEnabled(false)\n        Log.i(\"Toolbaronly_prepareoptionsmenu\",item?.title.toString())\n    }\n    return super.onPrepareOptionsMenu(menu)\n}\n</code></pre></p>"},{"location":"Android/Interficies/appbar/#4-gestio-de-la-appbar-amb-els-temes","title":"4. Gesti\u00f3 de la appbar amb els temes","text":"<p>La appbar per defecte, es mostra o no en funci\u00f3 del tema que estigui aplicat a l'activity:</p> <p>Tema amb appbar: <pre><code>    &lt;style name=\"Base.Theme.LaMevaApp\" parent=\"Theme.Material3.DayNight.DarkActionBar\"&gt;\n        &lt;!-- Customize your dark theme here. --&gt;\n        &lt;!-- &lt;item name=\"colorPrimary\"&gt;@color/my_dark_primary&lt;/item&gt; --&gt;\n    &lt;/style&gt;\n</code></pre> Tema sense appbar: <pre><code>    &lt;style name=\"Base.Theme.LaMevaApp\" parent=\"Theme.Material3.DayNight.NoActionBar\"&gt;\n        &lt;!-- Customize your dark theme here. --&gt;\n        &lt;!-- &lt;item name=\"colorPrimary\"&gt;@color/my_dark_primary&lt;/item&gt; --&gt;\n    &lt;/style&gt;\n</code></pre></p>"},{"location":"Android/Interficies/appbar/#personalitzacio-dactivities-amb-o-sense-appbar","title":"Personalitzaci\u00f3 d'activities amb o sense appbar.","text":"<p>Podem definir un conjunt de temes coherent que permeti que algunes de les teves activitats tinguin una barra d'aplicaci\u00f3 i altres no, tot utilitzant els mateixos colors de marca.</p>"},{"location":"Android/Interficies/appbar/#tema-base-de-laplicacio","title":"Tema Base de l'Aplicaci\u00f3","text":"<p>Primer, crea un tema base al teu fitxer themes.xml que contingui tots els teus colors, tipografies i estils personalitzats. </p> <p>Tamb\u00e9 definim el tema de l'aplicaci\u00f3  Aquest ser\u00e0 el tema principal de la teva aplicaci\u00f3. (Theme.MyCustomApp) (Cal definir tamb\u00e9 els colors a colors.xml)</p> <p>Tant el tema base com el de l'aplicaci\u00f3 tenen appbar (hereten de DarkActionBar)</p> <p><pre><code>&lt;resources xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;style name=\"Base.Theme.MyCustomApp\" parent=\"Theme.MaterialComponents.DayNight.DarkActionBar\"&gt;\n        &lt;item name=\"colorPrimary\"&gt;@color/my_primary_color&lt;/item&gt;\n        &lt;item name=\"colorSecondary\"&gt;@color/my_secondary_color&lt;/item&gt;\n        &lt;item name=\"android:textColorPrimary\"&gt;@color/my_text_primary&lt;/item&gt;\n        &lt;/style&gt;\n    &lt;style name=\"Theme.MyCustomApp\" parent=\"Base.Theme.MyCustomApp\"&gt;\n\n&lt;/resources&gt;\n</code></pre> Aquest ser\u00e0 el tema per defecte de l\u2019aplicaci\u00f3 (amb AppBar).\u200b</p> <p>A AndroidManifest.xml, aplica\u2019l a l\u2019: <p><code>xml &lt;application     ...     android:theme=\"@style/Theme.MyCustomApp\"&gt;     ...</code> Aix\u00f2 fa que totes les activities usin aquest tema, excepte les que el sobreescriguin.\u200b</p>"},{"location":"Android/Interficies/appbar/#tema-fill-sense-appbar","title":"Tema fill sense AppBar","text":"<p>Crea un tema que hereti del base per\u00f2 desactivi la barra d\u2019acci\u00f3 (ideal per pantalles fullscreen, login, splash, etc.):</p> <p><pre><code>&lt;style name=\"Theme.MyCustomApp.NoActionBar\" parent=\"Theme.MyCustomApp\"&gt;\n    &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt;\n    &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;\n&lt;/style&gt;\n</code></pre> Aix\u00ed es mantenen tots els colors i estils del tema de l'aplicaci\u00f3, per\u00f2 sense AppBar.\u200b</p>"},{"location":"Android/Interficies/appbar/#assignar-tema-per-activity","title":"Assignar tema per Activity","text":"<p>Al AndroidManifest.xml pots dir quines activities porten appbar (tema base) i quines no (tema sense barra):</p> <pre><code>&lt;application\n    ...\n    android:theme=\"@style/Theme.MyCustomApp\"&gt;\n\n    &lt;!-- Activity amb AppBar (usa el tema base) --&gt;\n    &lt;activity\n        android:name=\".MainActivity\" /&gt;\n\n    &lt;!-- Activity sense AppBar --&gt;\n    &lt;activity\n        android:name=\".LoginActivity\"\n        android:theme=\"@style/Theme.MyCustomApp.NoActionBar\" /&gt;\n\n    &lt;!-- Activity amb AppBar personalitzada --&gt;\n    &lt;activity\n        android:name=\".DetailsActivity\"\n        android:theme=\"@style/Theme.MyCustomApp.AppBar\" /&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"Android/Interficies/bottommenu/","title":"Bottom Menu","text":""},{"location":"Android/Interficies/bottommenu/#menu-de-navegacio-inferior-bottomnavigationview","title":"Men\u00fa de Navegaci\u00f3 Inferior (BottomNavigationView)","text":"<p>El BottomNavigationView gestiona la navegaci\u00f3 de nivell superior entre un nombre redu\u00eft de vistes principals.</p> <p>La seva funci\u00f3 principal \u00e9s la navegaci\u00f3 entre fragments o activities.</p>"},{"location":"Android/Interficies/bottommenu/#xml-de-menu-de-la-navegacio-inferior","title":"XML de Men\u00fa de la Navegaci\u00f3 Inferior","text":"<p>Per definir un men\u00fa, cal afegir-lo a la carpeta men\u00fa, en l'apartat recursos. (si no existeix, cal crear-lo fent un nou recurs de tipus men\u00fa)</p> <p></p> <p>Exemple: Recurs de Men\u00fa (res/menu/bottom_nav_menu.xml) <pre><code>&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;item\n        android:id=\"@+id/home_fragment\"\n        android:icon=\"@drawable/ic_home\"\n        android:title=\"Inici\" /&gt;\n    &lt;item\n        android:id=\"@+id/dashboard_fragment\"\n        android:icon=\"@drawable/ic_dashboard\"\n        android:title=\"Panell\" /&gt;\n    &lt;item\n        android:id=\"@+id/notifications_fragment\"\n        android:icon=\"@drawable/ic_notifications\"\n        android:title=\"Avisos\" /&gt;\n&lt;/menu&gt;\n</code></pre> Exemple: Layout de l'activity (fixeu-vos en la linia ressaltada) <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"&gt;\n\n    &lt;androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/fragment_container\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toTopOf=\"@id/bottom_navigation\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" /&gt;\n\n    &lt;com.google.android.material.bottomnavigation.BottomNavigationView\n        android:id=\"@+id/bottom_navigation\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?android:attr/windowBackground\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:menu=\"@menu/bottom_nav_menu\" /&gt; \n    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre></p> <p>Exemple: Gesti\u00f3 Manual de la Navegaci\u00f3 (Kotlin)</p> <pre><code>// ...\nval bottomNav: BottomNavigationView = findViewById(R.id.bottom_navigation)\n\nbottomNav.setOnItemSelectedListener { item -&gt;\n    val selectedFragment: Fragment? = when (item.itemId) {\n        R.id.home_fragment -&gt; HomeFragment()\n        R.id.dashboard_fragment -&gt; DashboardFragment()\n        R.id.notifications_fragment -&gt; NotificationsFragment()\n        else -&gt; null\n    }\n\n    // Realitza la transacci\u00f3 de Fragment manualment\n    if (selectedFragment != null) {\n        supportFragmentManager.beginTransaction()\n            .replace(R.id.fragment_container, selectedFragment)\n            .commit()\n    }\n    true // Indica que la selecci\u00f3 ha estat gestionada\n}\n// ...\n</code></pre>"},{"location":"Android/Interficies/dialegs/","title":"Dialogs i dialogfragment","text":"<p>Utilitzant dialogfragment i una subclasse d'aquest: Oficial: https://developer.android.com/guide/fragments/dialogs</p> <p>exemple https://www.youtube.com/watch?v=CXggjg9s4NA Interessant per utilitzar interface per retornar un objecte del dialog. Minut 15:00</p>"},{"location":"Android/Interficies/drawermenu/","title":"Navigation Drawer","text":""},{"location":"Android/Interficies/drawermenu/#1-drawer-menu","title":"1. Drawer Men\u00fa","text":"<p>Es presenta com un panell vertical que roman ocult i es fa visible lliscant-lo (normalment des de la vora esquerra de la pantalla, depenent de la configuraci\u00f3 de l'idioma) o prement la icona de men\u00fa/hamburguesa a la barra superior de l'aplicaci\u00f3.</p> <p>La seva funci\u00f3 principal \u00e9s estalviar espai a la pantalla i mantenir la interf\u00edcie neta, ja que agrupa les opcions de navegaci\u00f3 menys freq\u00fcentment utilitzades o que porten a pantalles de nivell superior, proporcionant un \u00fanic punt de salt a qualsevol secci\u00f3 principal de l'aplicaci\u00f3.</p>"},{"location":"Android/Interficies/drawermenu/#2-implementacio","title":"2. Implementaci\u00f3","text":""},{"location":"Android/Interficies/drawermenu/#recurs-de-menu-xml","title":"Recurs de Men\u00fa (XML)","text":"<p>Crea un nou fitxer de recurs de men\u00fa a res/menu/main_drawer_menu.xml. Aquest fitxer defineix els \u00edtems que es mostraran al panell lateral. <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;group android:checkableBehavior=\"single\"&gt;\n        &lt;item\n            android:id=\"@+id/nav_home\"\n            android:icon=\"@drawable/ic_home\"\n            android:title=\"Inici\" /&gt;\n        &lt;item\n            android:id=\"@+id/nav_gallery\"\n            android:icon=\"@drawable/ic_gallery\"\n            android:title=\"Galeria\" /&gt;\n        &lt;item\n            android:id=\"@+id/nav_settings\"\n            android:icon=\"@drawable/ic_settings\"\n            android:title=\"Configuraci\u00f3\" /&gt;\n    &lt;/group&gt;\n    &lt;item android:title=\"Comunicaci\u00f3\"&gt;\n        &lt;menu&gt;\n            &lt;item\n                android:id=\"@+id/nav_share\"\n                android:icon=\"@drawable/ic_share\"\n                android:title=\"Compartir\" /&gt;\n        &lt;/menu&gt;\n    &lt;/item&gt;\n&lt;/menu&gt;\n</code></pre></p>"},{"location":"Android/Interficies/drawermenu/#disseny-del-layout","title":"Disseny del Layout","text":"<p>El DrawerLayout \u00e9s el contenidor principal. Ha de contenir dos elements: el contingut principal de l'aplicaci\u00f3 i el panell de navegaci\u00f3.</p>"},{"location":"Android/Interficies/drawermenu/#21-activity_mainxml","title":"2.1 activity_main.xml","text":"<p><pre><code>&lt;androidx.drawerlayout.widget.DrawerLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" \n    tools:openDrawer=\"start\"&gt;\n\n    &lt;include\n        layout=\"@layout/app_bar_main\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" /&gt;\n\n    &lt;com.google.android.material.navigation.NavigationView\n        android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" \n        android:fitsSystemWindows=\"true\"\n        app:headerLayout=\"@layout/nav_header_main\" \n        app:menu=\"@menu/main_drawer_menu\" /&gt;\n\n&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;\n</code></pre> - DrawerLayout: L'arrel.12android:layout_gravity=\"start\": Crucial. Indica al DrawerLayout que el NavigationView \u00e9s el panell lateral i ha d'apar\u00e8ixer des de la vora inicial (esquerra, en la majoria d'idiomes). - app:menu: Enlla\u00e7a amb el fitxer de men\u00fa XML creat anteriorment.</p>"},{"location":"Android/Interficies/drawermenu/#22-implementacio-de-la-logica","title":"2.2 Implementaci\u00f3 de la L\u00f2gica","text":"<p>La l\u00f2gica es realitza a la MainActivity.kt. </p> <p>Es centra a sincronitzar el Drawer amb la barra d'eines i gestionar els clics.</p> <p>Exemple: <pre><code>import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.view.MenuItem\nimport android.widget.Toast\nimport androidx.appcompat.app.ActionBarDrawerToggle\nimport androidx.core.view.GravityCompat\nimport com.google.android.material.navigation.NavigationView\nimport androidx.drawerlayout.widget.DrawerLayout\n\nclass MainActivity : AppCompatActivity(), \n                     NavigationView.OnNavigationItemSelectedListener { // 1. Implementa el Listener\n\n    private lateinit var drawerLayout: DrawerLayout\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 2. Obtenci\u00f3 de les vistes\n        drawerLayout = findViewById(R.id.drawer_layout)\n        val navView: NavigationView = findViewById(R.id.nav_view)\n\n        // La Toolbar (assumint que s'ha incl\u00f2s a app_bar_main i se li ha assignat un ID 'toolbar')\n        val toolbar: androidx.appcompat.widget.Toolbar = findViewById(R.id.toolbar)\n        setSupportActionBar(toolbar) // Opcional: Si vols usar la Toolbar com a ActionBar\n\n        // 3. Sincronitzaci\u00f3 amb la Barra d'Eines (Icona d'Hamburguesa)\n        val toggle = ActionBarDrawerToggle(\n            this, \n            drawerLayout, \n            toolbar, \n            R.string.navigation_drawer_open, // String de recurs: \"Open navigation drawer\"\n            R.string.navigation_drawer_close // String de recurs: \"Close navigation drawer\"\n        )\n        drawerLayout.addDrawerListener(toggle)\n        toggle.syncState() // Sincronitza l'estat inicial de la icona\n\n        // 4. Establir el Listener per als Clics al Men\u00fa\n        navView.setNavigationItemSelectedListener(this)\n    }\n\n    // 5. Gesti\u00f3 dels Clics al Men\u00fa (Implementaci\u00f3 del Listener)\n    override fun onNavigationItemSelected(item: MenuItem): Boolean {\n        when (item.itemId) {\n            R.id.nav_home -&gt; {\n                Toast.makeText(this, \"Inici seleccionat\", Toast.LENGTH_SHORT).show()\n                // Aqu\u00ed va la l\u00f2gica per canviar Fragment / Activity\n            }\n            R.id.nav_gallery -&gt; {\n                Toast.makeText(this, \"Galeria seleccionada\", Toast.LENGTH_SHORT).show()\n            }\n            R.id.nav_settings -&gt; {\n                Toast.makeText(this, \"Configuraci\u00f3 seleccionada\", Toast.LENGTH_SHORT).show()\n            }\n            R.id.nav_share -&gt; {\n                Toast.makeText(this, \"Compartir seleccionat\", Toast.LENGTH_SHORT).show()\n            }\n        }\n\n        // Tanca el Drawer un cop s'ha seleccionat l'\u00edtem\n        drawerLayout.closeDrawer(GravityCompat.START)\n        return true\n    }\n\n    // 6. Gesti\u00f3 del Bot\u00f3 Enrere\n    override fun onBackPressed() {\n        if (drawerLayout.isDrawerOpen(GravityCompat.START)) {\n            // Si el Drawer est\u00e0 obert, el tanquem\n            drawerLayout.closeDrawer(GravityCompat.START)\n        } else {\n            // Si el Drawer est\u00e0 tancat, es permet la funci\u00f3 normal del bot\u00f3 Enrere\n            super.onBackPressed()\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Interficies/drawermenu/#3-resum-de-punts-clau","title":"3. Resum de Punts Clau","text":"Component Funci\u00f3 Notes Clau DrawerLayout Contenidor arrel que permet l'acci\u00f3 de lliscament. Ha de tenir dos fills: el contingut principal i el panell lateral. NavigationView El panell lateral amb el men\u00fa d'elements. Utilitza android:layout_gravity=\"start\" i app:menu. ActionBarDrawerToggle Classe que gestiona la interacci\u00f3 amb la Toolbar. S'encarrega de mostrar la icona d'hamburguesa i obrir/tancar el Drawer al clicar. onNavigationItemSelected M\u00e8tode del NavigationView. OnNavigationItemSelectedListener. On s'implementa la l\u00f2gica de navegaci\u00f3 real (Fragments, Activities). S'ha de tancar el Drawer despr\u00e9s de l'acci\u00f3. onBackPressed() M\u00e8tode de l'Activity. Es sobreescriu per interceptar el bot\u00f3 Enrere i tancar el Drawer abans de sortir de l'Activity."},{"location":"Android/Interficies/layouts/","title":"Layouts","text":"<p>Per fer !</p> <p>Documentaci\u00f3 oficial: https://developer.android.com/develop/ui/views/layout/declaring-layout</p>"},{"location":"Android/Interficies/layouts/#linear-layout","title":"Linear Layout","text":"<p>Per fer !</p>"},{"location":"Android/Interficies/layouts/#contraint-layout","title":"Contraint Layout","text":"<p>Per fer !</p>"},{"location":"Android/Interficies/layouts/#chains","title":"Chains","text":"<p>Per fer !</p>"},{"location":"Android/Interficies/menus/","title":"Men\u00fas","text":"<p>Per fer !</p> <p>Documentaci\u00f3 oficial https://developer.android.com/develop/ui/views/components/menus</p>"},{"location":"Android/Interficies/recyclerview/","title":"RecyclerView amb llista en mem\u00f2ria (Kotlin)","text":"<p>Documentaci\u00f3 oficial: https://developer.android.com/develop/ui/views/layout/recyclerview</p> <p>Exemple: https://github.com/davidfs-itic/RecyclerView</p>"},{"location":"Android/Interficies/recyclerview/#1-que-es-un-recyclerview","title":"1. Qu\u00e8 \u00e9s un RecyclerView?","text":"<p>Un RecyclerView \u00e9s un component que permet mostrar llistes (o graelles) d\u2019elements reciclant les vistes per millorar el rendiment. Substitueix l\u2019antic ListView i ofereix m\u00e9s flexibilitat (layout managers, animacions, etc.).</p> <p>Per utilitzar un RecyclerView cal:</p> <ul> <li>Una llista de dades (en mem\u00f2ria, en aquest exemple).</li> <li>Un layout XML per a la pantalla que cont\u00e9 el RecyclerView.</li> <li>Un layout XML per a cada fila (\u00edtem) de la llista.</li> <li>Un Adapter amb un ViewHolder per \u201cpintar\u201d les dades a cada fila.</li> </ul>"},{"location":"Android/Interficies/recyclerview/#2-model-de-dades-data-class-i-llista","title":"2. Model de dades (data class i llista)","text":""},{"location":"Android/Interficies/recyclerview/#data-class","title":"Data Class","text":"<p>Creem una classe senzilla per representar cada element de la llista.</p> <pre><code>// Fitxer: MyItem.kt\ndata class MyItem(\n    val title: String,\n    val subtitle: String\n)\n</code></pre>"},{"location":"Android/Interficies/recyclerview/#llista-de-dades-en-un-object-kotlin","title":"Llista de dades en un object (Kotlin)","text":""},{"location":"Android/Interficies/recyclerview/#que-es-un-object-a-kotlin","title":"Qu\u00e8 \u00e9s un object a Kotlin?","text":"<p>En Kotlin, un object \u00e9s una construcci\u00f3 que crea una \u00fanica inst\u00e0ncia (patr\u00f3 Singleton) de manera autom\u00e0tica. S\u2019utilitza quan es vol un \u00fanic punt d\u2019acc\u00e9s compartit, per exemple una llista de dades comuna per a diferents pantalles.</p>"},{"location":"Android/Interficies/recyclerview/#caracteristiques-principals","title":"Caracter\u00edstiques principals:","text":"<ul> <li>No cal fer new ni cridar cap constructor; s\u2019accedeix pel nom (DataSource.items).</li> <li>Es crea la inst\u00e0ncia la primera vegada que es fa servir.</li> <li>\u00c9s \u00fatil per guardar dades en mem\u00f2ria mentre l\u2019app est\u00e0 en execuci\u00f3.</li> </ul> <p>Objecte que cont\u00e9 la llista: DataSource</p> <p><pre><code>// Fitxer: DataSource.kt\n\n/**\n * Objecte singleton que proporciona dades en mem\u00f2ria\n * per ser utilitzades al RecyclerView.\n */\nobject DataSource {\n\n    // Llista de dades en mem\u00f2ria (nom\u00e9s de lectura)\n    val items: List&lt;MyItem&gt; = listOf(\n        MyItem(\"Element 1\", \"Subt\u00edtol 1\"),\n        MyItem(\"Element 2\", \"Subt\u00edtol 2\"),\n        MyItem(\"Element 3\", \"Subt\u00edtol 3\"),\n        MyItem(\"Element 4\", \"Subt\u00edtol 4\")\n    )\n}\n</code></pre> Qu\u00e8 f\u00e0 aquest codi?</p> <p><pre><code>object DataSource\n</code></pre> - Declara un objecte \u00fanic anomenat DataSource. - No s\u2019instancia amb DataSource(), sin\u00f3 que s\u2019utilitza directament pel nom.</p> <p><pre><code>val items: List&lt;MyItem&gt;\n</code></pre> - \u00c9s una propietat p\u00fablica que cont\u00e9 la llista en mem\u00f2ria. - El tipus \u00e9s List, per tant \u00e9s immutable (no es poden afegir/eliminar elements). - Es pot canviar a MutableList si es vol modificar la llista durant l\u2019execuci\u00f3. <p>L\u2019objecte DataSource actua com un \u201cmini repositori de dades\u201d senzill, sense base de dades ni API.</p> <p>(Per a veure com s'ha de crear un repositori de dades, veure l'apartat repositori a Arquitectura)</p>"},{"location":"Android/Interficies/recyclerview/#3-layout-de-cada-element-item_rowxml","title":"3. Layout de cada element (item_row.xml)","text":"<p>Aquest layout defineix com es veu una fila de la llista.</p> <pre><code>&lt;!-- Fitxer: res/layout/item_row.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\"\n    android:padding=\"16dp\"&gt;\n\n    &lt;TextView\n        android:id=\"@+id/tvTitle\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"T\u00edtol\"\n        android:textStyle=\"bold\"\n        android:textSize=\"18sp\" /&gt;\n\n    &lt;TextView\n        android:id=\"@+id/tvSubtitle\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Subt\u00edtol\"\n        android:textSize=\"14sp\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"Android/Interficies/recyclerview/#4-layout-amb-el-recyclerview-activity_mainxml","title":"4. Layout amb el RecyclerView (activity_main.xml)","text":"<p>Aquest layout cont\u00e9 el RecyclerView que ocupar\u00e0 tota la pantalla.</p> <pre><code>&lt;!-- Fitxer: res/layout/activity_main.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n\n    &lt;androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/recyclerView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre>"},{"location":"Android/Interficies/recyclerview/#5-adapter-i-viewholder-myadapterkt","title":"5. Adapter i ViewHolder (MyAdapter.kt)","text":"<p>En un RecyclerView aquestes classes sempre treballen juntes:</p>"},{"location":"Android/Interficies/recyclerview/#el-adapter-sap","title":"El Adapter sap:","text":"<ul> <li>Quantes files hi ha.</li> <li>Quin layout s\u2019utilitza per a cada fila.</li> <li>Quines dades s\u2019han de mostrar a cada posici\u00f3.</li> </ul>"},{"location":"Android/Interficies/recyclerview/#el-viewholder-sap","title":"El ViewHolder sap:","text":"<ul> <li>Quines vistes (TextView, ImageView, etc.) t\u00e9 una fila.</li> <li>On escriure les dades quan l\u2019Adapter li digui \u201cpinta l\u2019element X\u201d.</li> </ul> <p>Sense Adapter i ViewHolder, el RecyclerView no sap ni quantes files mostrar, ni com dibuixar-les.</p>"},{"location":"Android/Interficies/recyclerview/#exemple-codi-holder","title":"Exemple codi Holder","text":"<pre><code>// MyViewHolder.kt\nimport android.view.View\nimport android.widget.TextView\nimport androidx.recyclerview.widget.RecyclerView\n\n/**\n * ViewHolder responsable d'una fila del RecyclerView.\n * Encapsula la vista de la fila i sap com \"pintar-hi\" un MyItem.\n */\nclass MyViewHolder(\n    itemView: View,\n    private val onItemClick: (MyItem) -&gt; Unit\n) : RecyclerView.ViewHolder(itemView) {\n\n    private val tvTitle: TextView = itemView.findViewById(R.id.tvTitle)\n    private val tvSubtitle: TextView = itemView.findViewById(R.id.tvSubtitle)\n\n    /**\n     * Actualitza les vistes de la fila amb les dades de MyItem\n     * i configura els listeners d'esdeveniments.\n     */\n    fun bind(item: MyItem) {\n        tvTitle.text = item.title\n        tvSubtitle.text = item.subtitle\n\n        // Exemple de gesti\u00f3 de clic sobre tota la fila\n        itemView.setOnClickListener {\n            onItemClick(item)\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/recyclerview/#explicacio","title":"Explicaci\u00f3:","text":"<p>Classe</p> <p><pre><code>class MyViewHolder(... ) : RecyclerView.ViewHolder(itemView)\n</code></pre> Hereta de RecyclerView.ViewHolder i rep la vista de la fila (itemView) i una funci\u00f3 de clic (onItemClick).\u200b</p> <p>Propietats privades (tvTitle, tvSubtitle):</p> <p>El ViewHolder busca una sola vega*da les vistes del layout item_row.xml i s\u2019hi queda la refer\u00e8ncia.</p> <p>M\u00e8tode bind(item: MyItem):</p> <p>\u00c9s el punt \u00fanic per:  - Escriure dades a les vistes.  - Configurar listeners espec\u00edfics d\u2019aquesta fila (clic, long\u2011click\u2026).</p> <p>Aix\u00f2 treu responsabilitat de \u201cpintar dades\u201d de l\u2019Adapter i la concentra al ViewHolder.</p>"},{"location":"Android/Interficies/recyclerview/#exemple-codi-adapter","title":"Exemple codi Adapter","text":"<pre><code>// MyAdapter.kt\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.RecyclerView\n\n/**\n * Adapter que crea ViewHolder (MyViewHolder),\n * indica quants elements hi ha i demana que es \"pintin\" amb bind().\n */\nclass MyAdapter(\n    private val items: List&lt;MyItem&gt;,\n    private val onItemClick: (MyItem) -&gt; Unit\n) : RecyclerView.Adapter&lt;MyViewHolder&gt;() {\n\n    /**\n     * Crea (infla) la vista de la fila i construeix el ViewHolder.\n     */\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val inflater = LayoutInflater.from(parent.context)\n        val view = inflater.inflate(R.layout.item_row, parent, false)\n        return MyViewHolder(view, onItemClick)\n    }\n\n    /**\n     * Retorna quants elements hi ha a la llista de dades.\n     */\n    override fun getItemCount(): Int = items.size\n\n    /**\n     * Demana al ViewHolder que mostri les dades de la posici\u00f3 donada.\n     */\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        val item = items[position]\n        holder.bind(item)\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/recyclerview/#explicacio_1","title":"Explicaci\u00f3:","text":"<p>L\u2019Adapter ja no sap com s\u2019actualitzen exactament les vistes; delega aquesta feina a holder.bind(item).</p> <p>Responsabilitats clares de cada m\u00e8tode (tal com recomana la documentaci\u00f3 oficial):\u200b</p> <ul> <li>onCreateViewHolder: infla el layout i crea el ViewHolder.</li> <li>getItemCount: diu al RecyclerView quantes files han de existir.</li> <li>onBindViewHolder: passa el model (MyItem) al ViewHolder perqu\u00e8 l\u2019actualitzi.</li> </ul>"},{"location":"Android/Interficies/recyclerview/#6-activity","title":"6. Activity","text":"<p>Exemple de codi en l'activity.  Els comentaris expliquen els passos que s'han de seguir.</p> <pre><code>// MainActivity.kt\nimport android.os.Bundle\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var recyclerView: RecyclerView\n    private lateinit var adapter: MyAdapter\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 1. Obtenir refer\u00e8ncia al RecyclerView del layout\n        recyclerView = findViewById(R.id.recyclerView)\n\n        // 2. Configurar LayoutManager (com es col\u00b7loquen les files)\n        recyclerView.layoutManager = LinearLayoutManager(this)\n\n        // 3. Crear llista de dades (des de DataSource o directament)\n        val items = DataSource.items\n\n        // 4. Crear l'Adapter passant les dades + funci\u00f3 de callback per clics\n        adapter = MyAdapter(\n            items = items,\n            onItemClick = { item -&gt;\n                // AQU\u00cd gestionem el clic: mostrem un Toast amb el t\u00edtol\n                Toast.makeText(\n                    this,\n                    \"Has clicat: ${item.title}\",\n                    Toast.LENGTH_SHORT\n                ).show()\n            }\n        )\n\n        // 5. Assignar l'Adapter al RecyclerView\n        recyclerView.adapter = adapter\n    }\n}\n</code></pre> <p>Tot i que s'utilitza una funci\u00f3 (anomenada callback) per passar la l\u00f2gica de gesti\u00f3 del click en un \u00edtem (recodem que aix\u00f3 ho gestiona el ViewHolder), no \u00e9s una pr\u00e0ctica recomenada. Est\u00e0 aqu\u00ed per simplicitat.</p> <p>Veieu \"Exemple inversi\u00f3 de depend\u00e8ncies amb RecyclerView\" a l'apartat Arquitectura</p>"},{"location":"Android/Interficies/recyclerview/#7-resum","title":"7. Resum","text":""},{"location":"Android/Interficies/recyclerview/#idea-clau","title":"Idea clau:","text":"<p>En un RecyclerView, el ViewHolder encapsula la vista d\u2019una fila, en guarda les refer\u00e8ncies a les seves sub\u2011vistes i pot contenir la l\u00f2gica espec\u00edfica d\u2019aquesta fila (com ara actualitzar les dades o gestionar clics), mentre que l\u2019Adapter crea aquests ViewHolder, els recicla i els alimenta amb les dades correctes de la llista.</p> <ul> <li>onCreateViewHolder crea la vista i el ViewHolder.</li> <li>onBindViewHolder omple aquesta vista amb les dades de la posici\u00f3 concreta.</li> </ul>"},{"location":"Android/Interficies/recyclerview/#frase-resum-que-podeu-recordar","title":"Frase \u201cresum\u201d que podeu recordar:","text":"<p>L\u2019Adapter:</p> <ul> <li>Crea ViewHolder nous (onCreateViewHolder).</li> <li>Diu quantes files hi ha (getItemCount).</li> <li>Omple les vistes del ViewHolder amb dades (onBindViewHolder).</li> </ul> <p>El ViewHolder  - Guarda refer\u00e8ncies a les vistes de la fila (TextView, ImageView, etc.). - Encapsula la l\u00f2gica de \u201cbind\u201d: t\u00e9 una funci\u00f3 bind(item: MyItem) que rep el model i actualitza totes les vistes. - Gestiona esdeveniments de la fila: per exemple, configurar setOnClickListener sobre itemView o sobre algun bot\u00f3 concret, i notifica l\u2019Adapter o un listener extern.</p>"},{"location":"Android/Interficies/recyclerviewfilter/","title":"Recyclerview filtrat","text":""},{"location":"Android/Interficies/recyclerviewfilter/#com-aplicar-filtres-a-un-recyclervew","title":"Com aplicar filtres a un RecyclerVew","text":""},{"location":"Android/Interficies/recyclerviewfilter/#1-cal-fer-una-funcio-per-actualitzar-el-recyclerview","title":"1. Cal fer una funci\u00f3 per actualitzar el Recyclerview","text":"<p>```kotlin linenum=\"1\" class MyAdapter(     private val items: List,     private val onItemClick: (MyItem) -&gt; Unit ) : RecyclerView.Adapter() { <pre><code>override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n    val inflater = LayoutInflater.from(parent.context)\n    val view = inflater.inflate(R.layout.item_row, parent, false)\n    return MyViewHolder(view, onItemClick)\n}\n\noverride fun getItemCount(): Int = items.size\n\noverride fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n    val item = items[position]\n    holder.bind(item)\n}\n\nfun updateList(newList: List&lt;MyItem&gt;) {\n    items = newList\n    notifyDataSetChanged()\n}\n</code></pre> <p>} ``` </p>"},{"location":"Android/Interficies/recyclerviewfilter/#2-des-de-la-activity","title":"2. Des de la Activity:","text":""},{"location":"Android/Interficies/recyclerviewfilter/#fem-un-menu-per-buscar-per-exemple-un-popup-per-categories","title":"Fem un men\u00fa per buscar (per exemple un PopUp per categories)","text":"<p><code>kotlin &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;     &lt;item         android:id=\"@+id/cat_totes\"         android:title=\"Totes les Categories\" /&gt;     &lt;item         android:id=\"@+id/cat_peliculas\"         android:title=\"Pel\u00b7l\u00edcules\" /&gt;     &lt;item         android:id=\"@+id/cat_llibres\"         android:title=\"Llibres\" /&gt;     &lt;item         android:id=\"@+id/cat_musica\"         android:title=\"M\u00fasica\" /&gt; &lt;/menu&gt;</code></p>"},{"location":"Android/Interficies/recyclerviewfilter/#creem-el-menu-a-partir-del-xml","title":"Creem el men\u00fa a partir del xml","text":"<p>En l'event on onCreateOptionsMenu.</p> <pre><code>override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n\n        menuInflater.inflate(R.menu.menu_cerca, menu)\n\n        // 3. (OPCIONAL) **Configuraci\u00f3 del SearchView:**\n        // Aqu\u00ed \u00e9s on continuaries per obtenir les refer\u00e8ncies del SearchView\n        // i configurar els seus listeners.\n\n        // Exemple d'obtenci\u00f3 del SearchView:\n        // val searchItem: MenuItem? = menu?.findItem(R.id.action_cerca)\n        // val searchView = searchItem?.actionView as? SearchView\n        // Incialitzar el searchView amb les opcions i listeners.\n\n        return true // Retorna 'true' per indicar que el men\u00fa s'ha mostrat\n    }\n</code></pre>"},{"location":"Android/Interficies/recyclerviewfilter/#sobrescrivim-el-onoptionsitemselected","title":"Sobrescrivim el onOptionsItemSelected","text":"<p>Per capturar quan l'usuari seleccioni el item del men\u00fa</p> <pre><code>override fun onOptionsItemSelected(item: MenuItem): Boolean {\n    return when (item.itemId) {\n        R.id.action_category_button -&gt; {\n            // 1. Mostrar el PopupMenu\n            showCategoryPopupMenu(findViewById(R.id.action_category_button))\n            true\n        }\n        else -&gt; super.onOptionsItemSelected(item)\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/recyclerviewfilter/#creem-el-popupmenu","title":"Creem el PopUpMen\u00fa:","text":"<p>```kotlin private fun showCategoryPopupMenu(view: View) {</p> <pre><code>    // Inicialitza el PopupMenu amb el context de l'Activitat i el view del men\u00fa\n    val popup = PopupMenu(this, view)\n\n    // Infla el men\u00fa definit a popup_categories.xml\n    popup.menuInflater.inflate(R.menu.popup_categories, popup.menu)\n\n    // Defineix el Listener per gestionar les seleccions\n    popup.setOnMenuItemClickListener { menuItem -&gt;\n        when (menuItem.itemId) {\n            R.id.cat_totes -&gt; {\n                applyCategoryFilter(\"Totes\")\n                true\n            }\n            R.id.cat_peliculas -&gt; {\n                applyCategoryFilter(\"Pel\u00b7l\u00edcules\")\n                true\n            }\n            R.id.cat_llibres -&gt; {\n                applyCategoryFilter(\"Llibres\")\n                true\n            }\n            R.id.cat_musica -&gt; {\n                applyCategoryFilter(\"M\u00fasica\")\n                true\n            }\n            else -&gt; false\n        }\n    }\n\n    // Mostrar el men\u00fa\n    popup.show()\n}\n\nprivate fun applyCategoryFilter(category: String) {\n    Toast.makeText(this, \"Filtrat per: $category\", Toast.LENGTH_SHORT).show()\n    // Aqu\u00ed s'aplica la l\u00f2gica de filtratge a la RecyclerView o Llista.\n}\n```\n</code></pre>"},{"location":"Android/Interficies/splashscreen/","title":"Realitzar una splash screen","text":"<p>Android proporciona una API de Splash Screen que facilita la implementaci\u00f3 i assegura que la pantalla de presentaci\u00f3 es mostri correctament a partir d'Android 12, tot i que funciona amb una biblioteca de retrocompatibilitat per a versions anteriors.</p>"},{"location":"Android/Interficies/splashscreen/#1-dependencies","title":"1. Depend\u00e8ncies:","text":"<p>Afegir la Depend\u00e8ncia: Afegir la biblioteca androidx.core:core-splashscreen al teu fitxer build.gradle (m\u00f2dul: app).</p> <pre><code>dependencies {\n    ...\n    implementation 'androidx.core:core-splashscreen' \n    ...\n</code></pre> <p>Android studio suggerir\u00e0 la versi\u00f3 i si utilitzem el format libs.versions.toml suggerir\u00e0 fer el canvi.</p>"},{"location":"Android/Interficies/splashscreen/#2-tema","title":"2. Tema","text":"<p>Definir el Tema del Splash Screen (en themes.xml): Crear un estil que hereti de Theme.SplashScreen i especificar l'icona animada i el tema de la seg\u00fcent activitat.</p> <pre><code>&lt;style name=\"Theme.App.SplashScreen\" parent=\"Theme.SplashScreen\"&gt;\n&lt;item name=\"windowSplashScreenBackground\"&gt;@color/dark_grey&lt;/item&gt;\n    &lt;item name=\"windowSplashScreenAnimatedIcon\"&gt;@drawable/logo_animat&lt;/item&gt;\n    &lt;item name=\"postSplashScreenTheme\"&gt;@style/Base.Theme.LaMeuaApp&lt;/item&gt;\n    &lt;item name=\"windowSplashScreenAnimationDuration\"&gt;1000&lt;/item&gt;\n&lt;/style&gt;\n</code></pre> <p>Per tenir una icona animada (windowSplashScreenAnimatedIcon), pots utilitzar un Animated Vector Drawable (AVD), que \u00e9s un XML que defineix com un Vector Drawable canvia al llarg del temps.</p>"},{"location":"Android/Interficies/splashscreen/#3-manifest","title":"3. Manifest","text":"<p>Configurar el Manifest: Establir l'estil creat com el tema de la teva MainActivity (o l'activitat inicial) a AndroidManifest.xml.</p> <pre><code>&lt;activity\n    android:name=\".MainActivity\"\n    android:theme=\"@style/Theme.App.SplashScreen\"\n    ...&gt;\n    &lt;/activity&gt;\n</code></pre>"},{"location":"Android/Interficies/splashscreen/#4-controlar-la-durada-en-mainactivitykt","title":"4. Controlar la Durada (en MainActivity.kt):","text":"<p>A la teva activitat principal, has de cridar installSplashScreen() i pots utilitzar setKeepOnScreenCondition per mantenir la pantalla de presentaci\u00f3 visible fins que l'animaci\u00f3 hagi acabat o les dades s'hagin carregat.</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Cridar abans de super.onCreate() i setContentView()\n        val splashScreen = installSplashScreen()\n\n        // Opcional: Per mantenir-lo a la pantalla durant m\u00e9s temps (p. ex. carregar dades)\n        splashScreen.setKeepOnScreenCondition { \n            // Retorna 'true' per mantenir el splash screen, 'false' per amagar-lo\n            // Aqu\u00ed hi aniria la teva l\u00f2gica de c\u00e0rrega\n            false \n        }\n\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // ...\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/temes/","title":"Temes","text":"<p>Per Fer !</p> <p>Documentaci\u00f3  https://developer.android.com/develop/ui/views/theming/themes</p> <p>Codelab: https://developer.android.com/codelabs/basic-android-kotlin-training-change-app-theme?hl=es-419#0</p>"},{"location":"Android/Interficies/toolbar/","title":"Toolbar","text":""},{"location":"Android/Interficies/toolbar/#1-la-toolbar-com-a-appbar-fonaments","title":"1. La Toolbar com a AppBar (Fonaments)","text":""},{"location":"Android/Interficies/toolbar/#concepte-i-funcio","title":"Concepte i Funci\u00f3","text":"<p>L'AppBar (Barra d'Aplicacions) \u00e9s el component estructural m\u00e9s important a la part superior de qualsevol pantalla Android. </p> <p>El seu prop\u00f2sit \u00e9s: - Identitat: Mostrar el t\u00edtol de l'aplicaci\u00f3 o la pantalla actual. - Navegaci\u00f3: Allotjar el bot\u00f3 \"Up\" (fletxa enrere) o la icona del Navigation Drawer. - Accions: Contenir les accions m\u00e9s importants de la pantalla (men\u00fas).</p> <p>La Toolbar (proporcionada per la biblioteca AndroidX Material Components) \u00e9s la implementaci\u00f3 moderna i flexible de l'AppBar. A difer\u00e8ncia de l'antiga ActionBar nativa, la Toolbar pot ser personalitzada amb facilitat.</p> <p>La utilitzarem quan volguem personalitzar la appbar que apareix per defecte amb els temes.</p>"},{"location":"Android/Interficies/toolbar/#implementacio-basica","title":"Implementaci\u00f3 B\u00e0sica","text":"<p>Per utilitzar una Toolbar, primer s'ha d'afegir al fitxer XML del layout de l'Activity. Exemple: XML del Layout (activity_main.xml) <pre><code>&lt;LinearLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;androidx.appcompat.widget.Toolbar\n        android:id=\"@+id/my_toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" /&gt; \n\n    &lt;TextView \n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"El contingut de l'Activity va aqu\u00ed\"\n        android:padding=\"16dp\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> Despr\u00e9s, s'ha de configurar aquesta Toolbar com l'Action Bar de l'Activity en el codi Kotlin/Java, despr\u00e9s d'ocultar la barra nativa al tema de l'aplicaci\u00f3 (normalment, s'usa un tema NoActionBar), amb la funci\u00f3 setSupportActionBar</p> <p>Exemple: Configuraci\u00f3 a l'Activity (Kotlin) <pre><code>import androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val toolbar = findViewById&lt;Toolbar&gt;(R.id.my_toolbar)\n        // 1. Configura la Toolbar com l'Action Bar del sistema\n        setSupportActionBar(toolbar) \n\n        // Opcional: Estableix un t\u00edtol\n        supportActionBar?.title = \"La Meva App\" \n    }\n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#2-afegir-menus-a-la-toolbar","title":"2. Afegir Men\u00fas a la Toolbar","text":""},{"location":"Android/Interficies/toolbar/#definicio-del-menu","title":"Definici\u00f3 del Men\u00fa","text":"<p>Els \u00edtems del men\u00fa es defineixen en un fitxer XML separat a res/menu/.</p> <p>Exemple: Recurs de Men\u00fa (res/menu/main_menu.xml) <pre><code>&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt;\n\n    &lt;item\n        android:id=\"@+id/action_cercar\"\n        android:icon=\"@drawable/ic_search\" \n        android:title=\"Cercar\"\n        app:showAsAction=\"ifRoom\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/action_configuracio\"\n        android:title=\"Configuraci\u00f3\"\n        app:showAsAction=\"never\" /&gt;\n\n&lt;/menu&gt;\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#inflacio","title":"Inflaci\u00f3","text":"<p>El proc\u00e9s d'inflar (carregar) el men\u00fa XML a la Toolbar es fa sobreescrivint el m\u00e8tode onCreateOptionsMenu() de l'Activity. Exemple: Inflaci\u00f3 del Men\u00fa (Kotlin) <pre><code>class MainActivity : AppCompatActivity() {\n    // ... onCreate ...\n\n    override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n        // 1. Carrega el recurs de men\u00fa a l'Activity\n        menuInflater.inflate(R.menu.main_menu, menu)\n        return true // Retorna true per mostrar el men\u00fa\n    }\n    // ...\n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#gestio-de-clics-i-prioritat","title":"Gesti\u00f3 de Clics i Prioritat","text":"<p>Per respondre a les interaccions de l'usuari amb els \u00edtems del men\u00fa, s'ha de sobreescriure el m\u00e8tode onOptionsItemSelected(). Exemple 2.3: Gesti\u00f3 de Clics (Kotlin) <pre><code>    // ...\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            R.id.action_cercar -&gt; {\n                // L\u00f2gica per a l'acci\u00f3 de cercar\n                Toast.makeText(this, \"S'ha premut Cerca\", Toast.LENGTH_SHORT).show()\n                true\n            }\n            R.id.action_configuracio -&gt; {\n                // L\u00f2gica per anar a Configuraci\u00f3\n                Toast.makeText(this, \"Obrint Configuraci\u00f3...\", Toast.LENGTH_SHORT).show()\n                true\n            }\n            else -&gt; super.onOptionsItemSelected(item)\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#3-gestio-de-la-navegacio-a-lappbar","title":"3. Gesti\u00f3 de la Navegaci\u00f3 a l'AppBar","text":""},{"location":"Android/Interficies/toolbar/#el-boto-up","title":"El Bot\u00f3 \"Up\"","text":"<p>El bot\u00f3 \"Up\" (representat t\u00edpicament per una fletxa cap a l'esquerra: $\\leftarrow$) \u00e9s una convenci\u00f3 de disseny que permet a l'usuari navegar cap amunt en la jerarquia l\u00f2gica de l'aplicaci\u00f3, fins a la pantalla pare. </p> <p>\u00c9s diferent del bot\u00f3 \"Enrere\" del sistema, que navega pel registre hist\u00f2ric (back stack).</p>"},{"location":"Android/Interficies/toolbar/#integracio-de-la-navegacio","title":"Integraci\u00f3 de la Navegaci\u00f3","text":"<p>Quan s'utilitza la Toolbar com a Action Bar, el sistema pot gestionar autom\u00e0ticament el comportament del bot\u00f3 \"Up\" basant-se en la definici\u00f3 de l'Activity al fitxer AndroidManifest.xml (especificant l'Activity pare amb android:parentActivityName).</p> <p>Si no s'utilitza la Navigation Library, es pot habilitar el bot\u00f3 manualment i gestionar el seu clic:</p> <p>Exemple: Habilitaci\u00f3 del Bot\u00f3 \"Up\" (Kotlin) <pre><code>class DetailActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // ...\n\n        // Habilita el bot\u00f3 \"Up\" a la Toolbar\n        supportActionBar?.setDisplayHomeAsUpEnabled(true) \n    }\n\n    // Gesti\u00f3 manual del clic al bot\u00f3 \"Up\"\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            android.R.id.home -&gt; {\n                // El m\u00e8tode navigateUpFromSameTask() de l'Activity Manager \n                // compleix la funci\u00f3 del bot\u00f3 \"Up\"\n                NavUtils.navigateUpFromSameTask(this) \n                true\n            }\n            else -&gt; super.onOptionsItemSelected(item)\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#4-actualitzacio-dinamica-dels-menus","title":"4. Actualitzaci\u00f3 Din\u00e0mica dels Men\u00fas","text":"<p>De vegades, l'estat d'un \u00edtem de men\u00fa (p. ex., canviar una icona de \"No Favorit\" a \"Favorit\") ha de canviar mentre l'Activity est\u00e0 oberta.</p>"},{"location":"Android/Interficies/toolbar/#invalidacio-del-menu","title":"Invalidaci\u00f3 del Men\u00fa","text":"<p>Per for\u00e7ar que el sistema torni a cridar a onCreateOptionsMenu() i recre\u00ef completament el men\u00fa, s'utilitza invalidateOptionsMenu(). </p> <p>Aix\u00f2 \u00e9s \u00fatil si la visibilitat o el t\u00edtol d'alguns \u00edtems dep\u00e8n d'un estat global que acaba de canviar. Exemple: For\u00e7ar la Recreaci\u00f3 del Men\u00fa (Kotlin) <pre><code>// Despr\u00e9s d'un canvi d'estat a la nostra Activity...\nfun onDataUpdated() {\n    // ... \n    // Crida a invalidateOptionsMenu() per recrear el men\u00fa amb les noves dades\n    invalidateOptionsMenu() \n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#preparacio-del-menu","title":"Preparaci\u00f3 del Men\u00fa","text":"<p>El m\u00e8tode onPrepareOptionsMenu() es crida just abans que es mostri el men\u00fa. Aquest \u00e9s el lloc ideal per canviar la visibilitat o l'aparen\u00e7a dels \u00edtems de men\u00fa existents sense recrear tota l'estructura.</p> <p>Exemple: Preparaci\u00f3 Din\u00e0mica (Kotlin) <pre><code>// Variable d'estat a l'Activity\nprivate var isUserLoggedIn = false\n\noverride fun onPrepareOptionsMenu(menu: Menu?): Boolean {\n    val loginItem = menu?.findItem(R.id.action_login)\n    val logoutItem = menu?.findItem(R.id.action_logout)\n\n    // Mostra l'opci\u00f3 de login si l'usuari no est\u00e0 connectat, i viceversa\n    loginItem?.isVisible = !isUserLoggedIn\n    logoutItem?.isVisible = isUserLoggedIn\n\n    return super.onPrepareOptionsMenu(menu)\n}\n</code></pre></p>"},{"location":"Android/Interficies/toolbar/#5-action-views","title":"5. Action Views","text":"<p>Vegeu documentaci\u00f3 per a detalls: https://developer.android.com/develop/ui/views/components/appbar/action-views</p>"},{"location":"Android/Interficies/toolbar/#action-views","title":"Action Views","text":"<p>Un Action View \u00e9s un widget personalitzat (per exemple, un EditText, un SearchView, o un ProgressBar) que s'associa a un \u00edtem de men\u00fa. En lloc de mostrar la icona i el text habituals, l'\u00edtem de men\u00fa mostra el widget de l'Action View directament a la Toolbar. Caracter\u00edstiques: - Widget Incrustat: El SearchView \u00e9s l'exemple m\u00e9s com\u00fa. Quan l'usuari el selecciona, el widget s'expandeix a la barra d'aplicacions, permetent interaccions complexes (escriure, enviar) sense canviar d'Activity o mostrar un di\u00e0leg.</p> <ul> <li> <p>Implementaci\u00f3: Es defineix mitjan\u00e7ant l'atribut app:actionViewClass o android:actionLayout a l'XML del men\u00fa. Tamb\u00e9 es pot inflar manualment en el m\u00e8tode onCreateOptionsMenu().</p> </li> <li> <p>Gesti\u00f3 de Col\u00b7lapse: Quan l'Action View s'expandeix, altres accions de la Toolbar es poden col\u00b7lapsar (amagar). Pots implementar la interf\u00edcie MenuItem.OnActionExpandListener per gestionar esdeveniments quan l'acci\u00f3 s'expandeix o es col\u00b7lapsa.</p> </li> </ul> Searchview sense focus Searchview amb focus"},{"location":"Android/Interficies/toolbar/#6-estil-i-comportament-avancat-material-design","title":"6. Estil i Comportament Avan\u00e7at (Material Design)","text":""},{"location":"Android/Interficies/toolbar/#estil","title":"Estil","text":"<p>L'estil de l'AppBar (colors, fons, elevaci\u00f3) es controla principalment a trav\u00e9s del Tema de l'aplicaci\u00f3. Les propietats clau que afecten l'AppBar s\u00f3n:</p> <ul> <li> <p>colorPrimary: El color de fons principal de la barra.</p> </li> <li> <p>colorPrimaryVariant: S'utilitza sovint per a la Barra d'Estat (Status Bar).</p> </li> </ul>"},{"location":"Android/Interficies/toolbar/#comportament-avancat-amb-coordinatorlayout","title":"Comportament Avan\u00e7at amb CoordinatorLayout","text":"<p>Per a les aplicacions amb un disseny m\u00e9s sofisticat, la Toolbar s'integra amb un CoordinatorLayout i un AppBarLayout per crear efectes de despla\u00e7ament din\u00e0mics.</p>"},{"location":"Android/Interficies/toolbar/#exemple-defecte-de-desplacament","title":"Exemple d'Efecte de Despla\u00e7ament:","text":"<p>Si col\u00b7loques la Toolbar dins d'un AppBarLayout i el contingut despla\u00e7able (com un RecyclerView) tamb\u00e9 dins del CoordinatorLayout, pots utilitzar les scroll flags de l'AppBarLayout:</p> <pre><code>&lt;androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n    &lt;com.google.android.material.appbar.AppBarLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"&gt;\n        &lt;androidx.appcompat.widget.Toolbar\n            ...\n            app:layout_scrollFlags=\"scroll|enterAlways\" /&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt;\n\n    &lt;androidx.recyclerview.widget.RecyclerView\n        ...\n        app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt;\n&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;\n</code></pre> <p>scroll: Fa que la barra es mogui fora de la pantalla quan l'usuari es despla\u00e7a cap avall.</p> <p>enterAlways:  Fa que la barra torni a apar\u00e8ixer tan aviat com l'usuari comen\u00e7a a despla\u00e7ar-se cap amunt, fins i tot lleugerament.</p>"},{"location":"Android/Interficies/viewbinding/","title":"Viewbinding","text":"<p>https://developer.android.com/topic/libraries/view-binding</p> <p>El viewbinding \u00e9s una caracter\u00edstica (feature) que ens permet accedir als objectes que hi ha en una vista, directament sense haver de buscar-lo amb el findviewbyid</p> <p>S'activa d'aquesta manera, en el build.grade de nivell de m\u00f2dul</p> <pre><code>android {\n    ...\n    buildFeatures {\n        viewBinding = true\n    }\n}\n</code></pre> <p>El que far\u00e0 aquesta caracter\u00edstica, \u00e9s generar, per cada layout, una classe amb el nom del layout+binding, per exemple  per al layout activity_main es far\u00e0 la classe ActivityMainBinding  Aquesta classe, contindr\u00e0 tantes properties com elements visuals hi hagi en el layout, per exemple botons, textboxes, etc.</p> <p>Tamb\u00e9 t\u00e9 un m\u00e9tode getRoot() (o en kotlin, directament root) que accedeix al layout principal que cont\u00e9 la resta de la vista (linear o constraint layout)</p> <p>Per utilitzar-la, cal - Crear una variable d'aquest tipus (amb lateinit) - Crear la inst\u00e0ncia de la classe amb el m\u00e9tode static inflate() que crear\u00e0 l'objecte amb les properties necess\u00e0ries lligades als objectes que va creant del layout. - Utilitzar el setContentView() per a que l'activity es renderitzi a partir dels objectes creats.</p> <p>Exemple</p> <pre><code>private lateinit var binding: ActivityMainBinding\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    binding = ActivityMainBinding.inflate(layoutInflater)\n    setContentView(binding.root)\n}\n</code></pre> <p>A partir d'aqu\u00ed, es pot accedir als elements de la UI directament sense el findviewbyId</p> <pre><code>binding.mainTxt.setText(\"Login\")\n\nbinding.btnLogin.setOnClickListener({\n    doLogin()\n})\n</code></pre>"},{"location":"Android/Interficies/voicerecognition/","title":"Voice Recognition","text":""},{"location":"Android/Interficies/voicerecognition/#us-de-speechrecognizer-api-nativa","title":"\u00das de SpeechRecognizer (API nativa)","text":"<p>Android ja porta el reconeixedor integrat i no cal cap SDK extern.</p> <p>Passos:</p>"},{"location":"Android/Interficies/voicerecognition/#1-permis-al-manifest","title":"1. Perm\u00eds al manifest","text":"<pre><code>&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n</code></pre>"},{"location":"Android/Interficies/voicerecognition/#2-crear-el-reconeixedor","title":"2. Crear el reconeixedor","text":"<p>private lateinit var recognizer: SpeechRecognizer</p>"},{"location":"Android/Interficies/voicerecognition/#3-inicialitzar-lo","title":"3. Inicialitzar-lo","text":"<pre><code>recognizer = SpeechRecognizer.createSpeechRecognizer(this)\n\nval recognizerIntent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {\n    putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)\n    putExtra(RecognizerIntent.EXTRA_LANGUAGE, \"ca-ES\") // o \"es-ES\"\n}\n</code></pre>"},{"location":"Android/Interficies/voicerecognition/#4-assignar-un-listener","title":"4. Assignar un listener","text":"<pre><code>recognizer.setRecognitionListener(object : RecognitionListener {\n    override fun onResults(results: Bundle?) {\n        val spokenText = results\n            ?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)\n            ?.get(0)\n            ?.lowercase()\n\n        handleVoiceCommand(spokenText)\n    }\n\n    override fun onError(error: Int) {}\n    override fun onReadyForSpeech(params: Bundle?) {}\n    override fun onBeginningOfSpeech() {}\n    override fun onRmsChanged(rmsdB: Float) {}\n    override fun onBufferReceived(buffer: ByteArray?) {}\n    override fun onEndOfSpeech() {}\n    override fun onPartialResults(partialResults: Bundle?) {}\n    override fun onEvent(eventType: Int, params: Bundle?) {}\n})\n</code></pre>"},{"location":"Android/Interficies/voicerecognition/#5-interpretar-les-ordres","title":"5. Interpretar les ordres","text":"<pre><code>private fun handleVoiceCommand(command: String?) {\n    when {\n        command?.contains(\"endavant\") == true -&gt; {\n            // Obrir men\u00fa, navegar, etc.\n        }\n        command?.contains(\" enrere\") == true -&gt; {\n            onBackPressedDispatcher.onBackPressed()\n        }\n        command?.contains(\"acceptar\") == true -&gt; {\n            // Guardar dades, fer submit, etc.\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/voicerecognition/#6-per-activar-el-reconeixedor-quan-lusuari-parla","title":"6. Per activar el reconeixedor quan l\u2019usuari parla","text":"<p>alguna cosa com: <pre><code>buttonVoice.setOnClickListener {\n    recognizer.startListening(recognizerIntent)\n}\n</code></pre></p>"},{"location":"Android/Kotlin/","title":"Llenguatge Kotlin","text":"<p>Continguts:</p> <ul> <li>Variables i Constants: </li> <li>Funcions: </li> <li>Classes i Objectes:</li> <li>Null Safety: </li> <li>Funcions d'extensi\u00f3:</li> <li>LiveData: </li> <li>Coroutines:</li> <li>Anotadors:</li> </ul>"},{"location":"Android/Kotlin/#introduccio","title":"Introducci\u00f3","text":"<p>Kotlin \u00e9s un llenguatge de programaci\u00f3 modern creat per JetBrains i pensat, inicialment, per ser compatible amb Java. </p> <p>Avui en dia \u00e9s el llenguatge recomanat per Android i tamb\u00e9 s\u2019utilitza en molts altres \u00e0mbits. La seva filosofia principal \u00e9s ser un llenguatge m\u00e9s simple, segur i productiu que els que existien fins al moment, especialment comparat amb Java.</p> <p>Algunes caracter\u00edstiques generals:</p>"},{"location":"Android/Kotlin/#simplicitat-i-llegibilitat","title":"Simplicitat i llegibilitat","text":"<ul> <li>Kotlin busca reduir el codi que cal escriure. Moltes operacions que en altres llenguatges requereixen diverses l\u00ednies, en Kotlin es resolen de forma concisa.</li> <li>Aix\u00f2 facilita que el codi sigui m\u00e9s f\u00e0cil d\u2019entendre i mantenir.</li> </ul>"},{"location":"Android/Kotlin/#seguretat","title":"Seguretat","text":"<ul> <li>Kotlin incorpora mecanismes per evitar errors t\u00edpics, sobretot els relacionats amb valors nuls.</li> <li>Aquest tipus d\u2019error \u00e9s molt habitual en programaci\u00f3 i en Kotlin es controla de manera expl\u00edcita.</li> </ul>"},{"location":"Android/Kotlin/#compatibilitat-amb-java","title":"Compatibilitat amb Java","text":"<ul> <li>Kotlin funciona sobre la JVM (Java Virtual Machine), i un projecte pot barrejar fitxers Java i Kotlin sense problemes.</li> <li>A m\u00e9s, pot utilitzar totes les llibreries i frameworks que existeixen en Java.</li> </ul> <p>Aix\u00f2 permet migrar de Java a Kotlin de forma progressiva.</p>"},{"location":"Android/Kotlin/#versatilitat","title":"Versatilitat","text":"<p>Tot i que va n\u00e9ixer orientat a aplicacions Android, avui Kotlin s\u2019utilitza en molts camps:</p> <ul> <li>Aplicacions m\u00f2bils (Android)</li> <li>Backend (servidors) amb frameworks com Ktor o Spring Boot</li> <li>Aplicacions d'escriptori</li> <li>Desenvolupament web (Kotlin/JS)</li> <li>Multiplataforma (Kotlin Multiplatform), compartint codi entre Android, iOS i altres sistemes</li> </ul>"},{"location":"Android/Kotlin/#mes-eficient","title":"M\u00e9s eficient:","text":"<p>Alguns motius pels quals Kotlin ajuda a treballar de forma m\u00e9s eficient s\u00f3n:</p> <ul> <li>M\u00e9s facilitat per escriure codi que fa el mateix amb menys l\u00ednies</li> <li>Millor integraci\u00f3 amb l\u2019entorn Android Studio</li> <li>Sistema de tipus modern i m\u00e9s expressiu</li> <li>Funcions especials pensades per simplificar tasques habituals</li> </ul>"},{"location":"Android/Kotlin/anotadors/","title":"Anotadors","text":""},{"location":"Android/Kotlin/anotadors/#4-anotadors","title":"4. Anotadors","text":""},{"location":"Android/Kotlin/anotadors/#que-son","title":"Qu\u00e8 s\u00f3n","text":"<p>Els anotadors s\u00f3n una caracter\u00edstica del llenguatge Java (i Kotlin) que permeten afegir metadades al codi.</p> <p>Els anotadors (o Annotations) s\u00f3n una forma de metadada que es pot afegir al codi font.</p> <ol> <li> <p>Metadada, la clau La metadada \u00e9s \"data sobre data\". En programaci\u00f3, un anotador no cont\u00e9 l\u00f2gica ni executa cap acci\u00f3 per si mateix. Simplement etiqueta o descriu altres parts del codi, com classes, m\u00e8todes, variables o par\u00e0metres.</p> </li> <li> <p>Finalitat Principal El seu prop\u00f2sit principal \u00e9s ser llegits i processats per eines o frameworks en temps de compilaci\u00f3, en temps d'execuci\u00f3, o durant la generaci\u00f3 de documentaci\u00f3.</p> </li> <li> <p>Com Funcionen? Quan un anotador es posa sobre un element de codi, el framework que fa servir aquest codi pot:</p> <ul> <li> <p>Llegir-lo (Reflection): El framework (com Retrofit, Spring, o JUnit) inspecciona el codi durant l'execuci\u00f3 i detecta la pres\u00e8ncia i el valor dels anotadors.</p> </li> <li> <p>Modificar el Comportament: Basant-se en l'anotador, el framework canvia la manera com gestiona l'element.</p> </li> </ul> </li> </ol> <p>Exemples comuns en programaci\u00f3:</p> <ul> <li> <p>Retrofit: L'anotador @GET(\"ruta\") li diu a la llibreria que \"aquest m\u00e8tode ha de generar una petici\u00f3 HTTP GET a la ruta especificada.\"</p> </li> <li> <p>Testing (JUnit): L'anotador @Test li diu a l'eina de proves que \"aquest m\u00e8tode \u00e9s una prova i ha de ser executat.\"</p> </li> <li> <p>Android: L'anotador @Override li diu al compilador que \"aquest m\u00e8tode est\u00e0 substituint un m\u00e8tode de la classe pare, per la qual cosa s'ha de comprovar la signatura.\"</p> </li> </ul>"},{"location":"Android/Kotlin/anotadors/#anotadors-de-retrofit","title":"Anotadors de Retrofit","text":"<p>Es divideixen principalment en dues categories: els que defineixen el m\u00e8tode HTTP i la URL i els que defineixen els par\u00e0metres que s'envien amb aquesta petici\u00f3.</p>"},{"location":"Android/Kotlin/anotadors/#anotadors-de-metode-http-i-url-base","title":"Anotadors de M\u00e8tode HTTP i URL Base","text":"Anotador Categoria Funci\u00f3 Exemple d'\u00das @GET HTTP Sol\u00b7licita dades d'un recurs especificat. S'utilitza per obtenir (llegir) dades.    @GET(\"users/list\") @POST HTTP Envia dades a un recurs per crear-ne un de nou o processar-les. @POST(\"users/create\") @PUT HTTP S'utilitza per actualitzar (modificar completament) un recurs existent amb les dades proporcionades. @PUT(\"users/{id}\") @DELETE HTTP Sol\u00b7licita l'eliminaci\u00f3 d'un recurs especificat. @DELETE(\"users/{id}\") @PATCH HTTP S'utilitza per aplicar modificacions parcials a un recurs. @PATCH(\"users/{id}\") @HEAD HTTP Demana nom\u00e9s les cap\u00e7aleres de resposta sense el cos de la resposta. \u00datil per comprovar l'exist\u00e8ncia. @HEAD(\"health\") @HTTP HTTP M\u00e8tode m\u00e9s general per fer peticions HTTP sense els anotadors espec\u00edfics (@GET, @POST, etc.). Poc com\u00fa. @HTTP(method = \"DELETE\", path = \"users/{id}\", hasBody = false)"},{"location":"Android/Kotlin/anotadors/#anotadors-de-parametres-com-senvia-la-informacio","title":"Anotadors de Par\u00e0metres (Com s'Envia la Informaci\u00f3)","text":"<p>Per la URL</p> Anotador Funci\u00f3 Descripci\u00f3 Exemple @Path Ruta din\u00e0mica Substitueix un par\u00e0metre entre claus {} a la URL de la petici\u00f3. Obligatori per a rutes din\u00e0miques. @GET(\"items/{id}\") fun getItem(@Path(\"id\") itemId: Int) @Query Par\u00e0metre de consulta Afegeix un par\u00e0metre a la URL despr\u00e9s del signe d'interrogaci\u00f3 (?). \u00datil per a filtres i paginaci\u00f3. @GET(\"items\") fun filterItems(@Query(\"type\") type: String) Genera: /items?type=Electronics @QueryMap Consulta m\u00faltiple Permet enviar m\u00faltiples par\u00e0metres de consulta utilitzant un mapa de Kotlin (Map). fun getItems(@QueryMap options: Map) <p>Per al Cos de la Petici\u00f3 (Dades enviades) Anotador    | Funci\u00f3    | Descripci\u00f3    |Exemple :-----------|:----------|:--------------|:---------------- @Body|Cos de la petici\u00f3|\"Utilitzat en peticions @POST, @PUT o @PATCH. El par\u00e0metre de la funci\u00f3 (un objecte Kotlin) es serialitza (normalment a JSON) i s'envia com a cos de la petici\u00f3.\"|fun createItem(@Body item: ItemRequest) @FormUrlEncoded|Format de formulari|Utilitzat juntament amb @Field quan s'envien dades amb el format tradicional application/x-www-form-urlencoded.|Cal usar-lo a la funci\u00f3! @Field|Camp de formulari|S'utilitza nom\u00e9s en combinaci\u00f3 amb @FormUrlEncoded. Envia dades com a parelles clau-valor en el cos.|\"fun login(@Field(\"\"user\"\") u: String, @Field(\"\"pass\"\") p: String)\"</p> <p>Per a Cap\u00e7aleres (Metadata) Anotador    | Funci\u00f3    | Descripci\u00f3    |Exemple :-----------|:----------|:--------------|:---------------- @Header|Cap\u00e7alera din\u00e0mica|Permet afegir una cap\u00e7alera HTTP de manera din\u00e0mica (el seu valor prov\u00e9 d'un par\u00e0metre de la funci\u00f3). \u00datil per a tokens d'autenticaci\u00f3.|\"fun secureCall(@Header(\"\"Authorization\"\") token: String)\" @Headers|Cap\u00e7alera est\u00e0tica|Permet afegir cap\u00e7aleres HTTP fixes directament a la funci\u00f3 sense que depenguin d'un par\u00e0metre.|\"@Headers(\"\"Cache-Control: max-age=640000\"\") Cal usar-lo a la funci\u00f3!\"</p> <p>Per a Multipart (Fitxers) Anotador    | Funci\u00f3    | Descripci\u00f3    |Exemple :-----------|:----------|:--------------|:---------------- Anotador,Funci\u00f3,Descripci\u00f3,Exemple @Multipart|Fitxers m\u00faltiples|Indica que la petici\u00f3 \u00e9s de tipus multipart i s'utilitza per pujar fitxers amb dades addicionals.|Cal usar-lo a la funci\u00f3! @Part|Part de dades/fitxer|Defineix una part individual d'una petici\u00f3 multipart. Pot ser un camp de dades simple o un fitxer (utilitzant RequestBody).|fun uploadFile(@Part file: RequestBody)</p>"},{"location":"Android/Kotlin/classesobjectes/","title":"Classes i objectes en kotlin","text":""},{"location":"Android/Kotlin/classesobjectes/#classes","title":"Classes","text":"<ul> <li>Son finals per defecte</li> </ul>"},{"location":"Android/Kotlin/classesobjectes/#absencia-de-new","title":"Abs\u00e8ncia de New","text":"<p>No cal posar new</p> <pre><code>val persona = Persona(\"Joan\")\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#constructors-mes-simples","title":"Constructors m\u00e9s simples","text":"<p>Kotlin incorpora el constructor en la cap\u00e7alera:</p> <pre><code>class Persona(val nom: String, var edat: Int,x:Int)\n</code></pre> <p>Si no s'acompanya var o val, la variable nom\u00e9s s'utilitza en el constructor</p>"},{"location":"Android/Kotlin/classesobjectes/#a-kotlin-no-cal-escriure-getterssetters","title":"A Kotlin no cal escriure getters/setters:","text":"<p>Es generen autom\u00e0ticament segons val (nom\u00e9s lectura) o var (mutable).</p>"},{"location":"Android/Kotlin/classesobjectes/#constructor","title":"Constructor","text":"<p>Init executa el codi quan l'objecte es crea:</p> <p><pre><code>class Circle(i: Int) {  \n   init {\n        ... \n   }\n}\n</code></pre> \u00c9s t\u00e8cnicament el mateix que </p> <pre><code>class Circle {\n    constructor(i: Int) {\n        ...\n    }\n}\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#getters-i-setters","title":"Getters i Setters","text":"<p>Es poden sobreescriure els getters i setters per defecte:</p> <pre><code>class Person(val firstName: String, val lastName:String) {\n    val fullName:String\n        get() {\n            return \"$firstName $lastName\"\n        }\n}\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#herencia","title":"Her\u00e8ncia","text":"<ul> <li>Kotlin t\u00e9 her\u00e8ncia de classe amb un \u00fanic pare (single-parent class inheritance)</li> <li>Cada classe t\u00e9 exactament una classe pare, anomenada superclasse</li> <li>Cada subclasse hereta tots els membres de la seva superclasse, inclosos els que la superclasse mateixa ha heretat</li> </ul>"},{"location":"Android/Kotlin/classesobjectes/#classes-especials","title":"Classes especials","text":""},{"location":"Android/Kotlin/classesobjectes/#data-class","title":"Data class","text":"<p>Classe pensada per contenir dades</p> <p>Generen autom\u00e0ticament:</p> <p>\u2714 equals() \u2714 hashCode() \u2714 toString() \u2714 copy() \u2714 destructuring</p> <pre><code>data class Alumne(val nom: String, val edat: Int)\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#pair-i-triple-son-dataclasses-predefinides","title":"Pair i Triple son dataclasses predefinides:","text":"<p>Guarden un parell o tres valors</p> <p>Accedim a les seves propietat amb .first, .second, .third <pre><code>val bookAuthor = Pair(\"Harry Potter\", \"J.K. Rowling\")\nprintln(bookAuthor.first)\n</code></pre></p> <p>Pair t\u00e9 .to per ometre par\u00e8ntesis</p> <pre><code>val bookAuth1 = \"Harry Potter\".to(\"J. K. Rowling\")\nval bookAuth2 = \"Harry Potter\" to \"J. K. Rowling\"\nval map = mapOf(1 to \"x\", 2 to \"y\", 3 to \"zz\")\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#enum-class","title":"Enum class","text":"<p>Tipus de dada predefinit per a un conjunt de valors <pre><code>enum class Color(val r: Int, val g: Int, val b: Int) {\n   RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255)\n}\nprintln(\"\" + Color.RED.r + \" \" + Color.RED.g + \" \" + Color.RED.b)\n</code></pre></p>"},{"location":"Android/Kotlin/classesobjectes/#sealed-class","title":"Sealed class","text":"<p>Caracter\u00edstiques:</p> <ul> <li>Sembla a una enum, per\u00f2 m\u00e9s avan\u00e7ada, amb dades i comportament.</li> <li>Una sealed class no es pot estendre fora del mateix fitxer on est\u00e0 definida.</li> <li>Aix\u00f2 vol dir que totes les subclasses possibles estan controlades i limitades.</li> </ul> <pre><code>sealed class Operacio {\n    class Suma(val a: Int, val b: Int) : Operacio()\n    class Resta(val a: Int, val b: Int) : Operacio()\n    class Quadrat(val a: Int) : Operacio()\n}\n</code></pre> <p>Les sealed classes serveixen per:</p> <ul> <li>Restringir el polimorfisme</li> <li>Garantir tractament complet a when</li> <li>Substituir enums quan es necessita informaci\u00f3</li> <li>Fer el codi m\u00e9s segur i expressiu</li> <li>Evitar errors inesperats en her\u00e8ncies</li> </ul> <p>S\u00f3n ideals quan sabem tots els casos possibles i no volem que ning\u00fa en defineixi de nous.</p> <p>El compilador ens avisaria si en el when: falta algun cas, o no els posem tots  <pre><code>fun calcula(op: Operacio): Int {\n    return when(op) {\n        is Operacio.Suma -&gt; op.a + op.b\n        is Operacio.Resta -&gt; op.a - op.b\n        is Operacio.Quadrat -&gt; op.a * op.a\n    }\n}\n</code></pre></p>"},{"location":"Android/Kotlin/classesobjectes/#interficies","title":"Interf\u00edcies","text":"<ul> <li>Proporcionen un contracte al qual les classes s'hi han d'adherir (han d'implementar els m\u00e9todes)</li> <li>Poden contenir implementaci\u00f3 per defecte (m\u00e9todes abstractes i implmenentats)</li> <li>Poden heredar d'altres interf\u00edcies</li> <li>Poden tenir propietats</li> <li>Permeten m\u00faltiples her\u00e8ncies</li> <li>Poden contenir membres est\u00e0tics en forma de companion objects</li> </ul> <pre><code>interface Shape {\n    val name:String\n    fun computeArea() : Double\n}\nclass Circle(val radius:Double) : Shape {\n    override fun computeArea() = Math.PI * radius * radius\n}\nval c = Circle(3.0)\nprintln(c.computeArea())\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#objectes-en-kotlin","title":"Objectes en Kotlin","text":"<p>La paraula object: declara singletons reals</p> <pre><code>object Configuracio {\n    val versio = \"1.0\"\n}\n</code></pre> <p>Equivalent al patr\u00f3 Singleton en Java, per\u00f2 autom\u00e0tic:</p> <ul> <li>inst\u00e0ncia \u00fanica</li> <li>inicialitzaci\u00f3 garantida</li> <li>accessible directament:</li> </ul> <pre><code>println(Configuracio.versio)\n</code></pre>"},{"location":"Android/Kotlin/classesobjectes/#object-expressions-objectes-anonims","title":"Object expressions (objectes an\u00f2nims)","text":"<p><pre><code>val listener = object : OnClickListener {\n    override fun onClick() {\n        println(\"Click!\")\n    }\n}\n</code></pre> -&gt; substitueix new Interface() de Java</p>"},{"location":"Android/Kotlin/classesobjectes/#companion-objects-equivalent-a-membres-estatics","title":"Companion objects (equivalent a membres est\u00e0tics)","text":"<p>A Kotlin no existeixen les variables est\u00e0tiques de classe (static). En lloc seu, s\u2019utilitza companion object:</p> <p><pre><code>class Persona {\n    companion object {\n        val MAX_EDAT = 120\n    }\n}\n\nprintln(Persona.MAX_EDAT)\n</code></pre> Equivalent aproximadament a:</p> <pre><code>public class Persona {\n    public static final int MAX_EDAT = 120;\n}\n</code></pre>"},{"location":"Android/Kotlin/coroutines/","title":"Corrutines","text":"<p>Les corrutines s\u00f3n una de les caracter\u00edstiques m\u00e9s potents i diferencials del llenguatge Kotlin. Serveixen per gestionar tasques as\u00edncrones i concurrents d\u2019una manera molt m\u00e9s senzilla, segura i llegible que amb fils (threads) tradicionals.</p> <ul> <li>https://www.youtube.com/watch?v=vQ0w4zAe68A&amp;t=943</li> <li>https://developer.android.com/kotlin/coroutines?hl=es-419</li> </ul>"},{"location":"Android/Kotlin/coroutines/#que-es-una-corrutina","title":"Qu\u00e8 \u00e9s una corrutina?","text":"<p>Una corrutina \u00e9s una unitat d'execuci\u00f3 lleugera que es pot pausar i reprendre sense bloquejar el fil principal del programa.</p> <ul> <li>Es podrien descriure com \u201cthreads lleugers\u201d</li> <li>Permeten fer processos costosos sense congelar la UI</li> <li>Fan el codi as\u00edncron m\u00e9s intu\u00eftiu i lineal</li> <li>Es poden cancelar autom\u00e0ticament</li> </ul>"},{"location":"Android/Kotlin/coroutines/#per-que-sutilitzen","title":"Per qu\u00e8 s\u2019utilitzen?","text":"<p>Quan programem, especialment en aplicacions Android, sovint tenim tasques com:</p> <ul> <li>Accedir a la base de dades</li> <li>Fer peticions HTTP (APIs)</li> <li>Llegir fitxers</li> <li>Fer c\u00e0lculs costosos</li> </ul> <p>Si aquestes tasques s'executessin al fil principal, bloquejaria la interf\u00edcie gr\u00e0fica.</p> <p>Les corrutines resolen aquest problema executant-se en un fil secundari i tornant el resultat quan est\u00e0 llest.</p>"},{"location":"Android/Kotlin/coroutines/#elements-principals-de-les-corrutines","title":"Elements principals de les corrutines","text":""},{"location":"Android/Kotlin/coroutines/#1-coroutinescope","title":"1. CoroutineScope","text":"<p>\u00c9s el \u201ccontext\u201d on viuen les corrutines.</p> <p>Exemples de scopes:</p> <p>Scope | \u00das |:----|:---- GlobalScope |corrutina global durant tota l'app MainScope   |vinculat a UI lifecycleScope  |Android \u2013 vinculat al cicle de vida viewModelScope  |Android \u2013 s\u2019atura quan el ViewModel mor</p>"},{"location":"Android/Kotlin/coroutines/#2-launch-vs-async","title":"2. launch vs async","text":""},{"location":"Android/Kotlin/coroutines/#launch","title":"launch","text":"<p>Executa una corrutina sense retornar resultat</p> <pre><code>lifecycleScope.launch {\n    println(\"Aix\u00f2 \u00e9s una tasca as\u00edncrona\")\n}\n</code></pre>"},{"location":"Android/Kotlin/coroutines/#async","title":"async","text":"<p>Retorna un objecte Deferred i es pot recollir el resultat amb await() <pre><code>val resultat = async {\n    10 + 20\n}.await()\nprintln(resultat)\n</code></pre>"},{"location":"Android/Kotlin/coroutines/#3-suspend-functions","title":"3. Suspend functions","text":"<p>Una funci\u00f3 marcada amb suspend pot ser pausada i continua en un altre moment.</p> <pre><code>suspend fun carregarDades(): String {\n    delay(2000) // simula temps d\u2019espera\n    return \"Dades carregades\"\n}\n</code></pre> <p>Nom\u00e9s es pot cridar des de:</p> <ul> <li>una corrutina</li> <li>una altra funci\u00f3 suspend</li> </ul>"},{"location":"Android/Kotlin/coroutines/#dispatchers-on-sexecuten","title":"Dispatchers (On s\u2019executen?)","text":"<p>Els dispatchers indiquen en quin fil s'executa la corrutina:</p> <p>Dispatcher|\u00das |:--------|:--- Dispatchers.Main    |tasques de UI Dispatchers.IO  |fitxers, base de dades, xarxa Dispatchers.Default |c\u00e0lculs pesats Dispatchers.Unconfined  |poc utilitzat</p> <p>Exemple:</p> <pre><code>launch(Dispatchers.IO) {\n    val dades = carregarDades()\n    withContext(Dispatchers.Main) {\n        // actualitzar UI\n        textView.text = dades\n    }\n}\n</code></pre>"},{"location":"Android/Kotlin/coroutines/#que-es-withcontext","title":"Qu\u00e8 \u00e9s withContext?","text":"<p>withContext \u00e9s una funci\u00f3 de suspensi\u00f3 (suspend) que permet canviar el dispatcher o context dins d\u2019una corrutina i executar un bloc de codi en aquest nou context, sense crear una nova corrutina.</p> <p>\u00c9s \u00fatil per fer tasques de fons (IO, c\u00e0lculs) i despr\u00e9s tornar a la UI per actualitzar-la.</p> <p>Retorna el resultat del bloc que executa.</p> <pre><code>val resultat = withContext(Dispatchers.IO) {\n    // codi que s'executa en un fil d'entrada/sortida (IO)\n    carregarDadesPesades()\n}\n</code></pre>"},{"location":"Android/Kotlin/coroutines/#diferencia-entre-withcontext-launch-i-async","title":"Difer\u00e8ncia entre withContext launch i async","text":"<p>Funci\u00f3| Quan usar-la|   Retorna resultat? |:----|:------------|:--------- launch  |Crear una corrutina nova   |No async   |Crear corrutina que retorna un resultat    |S\u00ed, Deferred.await() withContext |Canviar context dins d\u2019una corrutina existent  |S\u00ed, retorna el valor del bloc</p>"},{"location":"Android/Kotlin/fextensio/","title":"Funcions d'extensi\u00f3","text":""},{"location":"Android/Kotlin/fextensio/#1-que-son-les-funcions-dextensio","title":"1. Qu\u00e8 s\u00f3n les Funcions d'Extensi\u00f3?","text":"<p>Una funci\u00f3 d'extensi\u00f3 \u00e9s una funci\u00f3 que es declara fora d'una classe, per\u00f2 que es pot cridar com si fos un m\u00e8tode d'aquesta classe.</p> <p>Sintaxi: Es defineix prefixant el nom de la funci\u00f3 amb el tipus que s'est\u00e9n (el tipus receptor), seguit d'un punt (.) i el nom de la funci\u00f3.</p> <p>Acc\u00e9s: Dins de la funci\u00f3 d'extensi\u00f3, pots accedir a les propietats i m\u00e8todes p\u00fablics del tipus est\u00e8s mitjan\u00e7ant la paraula clau this, que es refereix a la inst\u00e0ncia del receptor.</p> <p>L'\u00fas principal \u00e9s fer el codi m\u00e9s llegible i conc\u00eds, evitant la necessitat de classes utilit\u00e0ries plenes de m\u00e8todes est\u00e0tics. S\u00f3n molt comunes a la llibreria est\u00e0ndard de Kotlin (per exemple, funcions com .map(), .filter(), o .joinToString() en col\u00b7leccions s\u00f3n funcions d'extensi\u00f3).</p>"},{"location":"Android/Kotlin/fextensio/#2-exemple-practic-funcio-dextensio","title":"2. Exemple Pr\u00e0ctic funci\u00f3 d'extensi\u00f3","text":"<p>Imagina que sovint necessites una funci\u00f3 per capitalitzar la primera lletra d'una cadena (String). En lloc de crear una classe utilit\u00e0ria, pots estendre directament la classe String.</p>"},{"location":"Android/Kotlin/fextensio/#codi-de-la-funcio-dextensio","title":"Codi de la Funci\u00f3 d'Extensi\u00f3","text":"<p>Definim una funci\u00f3 d'extensi\u00f3 anomenada capitalizeFirstLetter per al tipus String:</p> <pre><code>// Extensions.kt\nfun String.capitalizeFirstLetter(): String {\n    // Si la cadena est\u00e0 buida o \u00e9s null (tot i que String no pot ser null), \n    // retornem la cadena tal com est\u00e0 per seguretat.\n    if (this.isEmpty()) return this\n\n    // La paraula clau 'this' fa refer\u00e8ncia a la inst\u00e0ncia de String \n    // sobre la qual s'est\u00e0 cridant la funci\u00f3 (el receptor).\n    return this.substring(0, 1).uppercase() + this.substring(1)\n}\n</code></pre>"},{"location":"Android/Kotlin/fextensio/#com-sutiliza","title":"Com S'Utiliza","text":"<p>Ara, pots cridar aquesta funci\u00f3 directament sobre qualsevol inst\u00e0ncia de String, com si fos un m\u00e8tode propi de la classe:</p> <pre><code>fun main() {\n    val textNormal = \"hola m\u00f3n\"\n    val textCapitalitzat = textNormal.capitalizeFirstLetter()\n\n    println(\"Original: $textNormal\")\n    println(\"Capitalitzat: $textCapitalitzat\")\n    // Sortida: Original: hola m\u00f3n\n    // Sortida: Capitalitzat: Hola m\u00f3n\n\n    val altreText = \"kotlin\"\n    println(altreText.capitalizeFirstLetter()) // Sortida: Kotlin\n}\n</code></pre> <p>D'aquesta manera qualsevol variable del tipus de la classe extesa, pot utilitzar la funci\u00f3 en qualsevol part del codi.</p>"},{"location":"Android/Kotlin/fextensio/#3-que-son-les-propietats-dextensio","title":"3. Qu\u00e8 s\u00f3n les Propietats d'Extensi\u00f3?","text":"<p>Una propietat d'extensi\u00f3 \u00e9s essencialment un camp que pots llegir o modificar directament sobre la inst\u00e0ncia d'una classe, tot i que aquesta propietat no forma part de la definici\u00f3 original de la classe.</p> <ul> <li>No emmagatzemen estat: \u00c9s important entendre que les propietats d'extensi\u00f3 no poden inicialitzar-se amb un backing field (\u00e9s a dir, no poden emmagatzemar dades). </li> <li>Han de ser propietats calculades que nom\u00e9s tenen un getter i, opcionalment, un setter.</li> <li>Sintaxi: S'assembla molt a la definici\u00f3 d'una propietat normal, per\u00f2 prefixant-la amb el nom de la classe que s'est\u00e9n.</li> </ul>"},{"location":"Android/Kotlin/fextensio/#4-exemple-practic-propietat-calculada","title":"4. Exemple Pr\u00e0ctic: Propietat Calculada","text":"<p>Imagina que tens una classe String i vols una manera r\u00e0pida de comprovar si una cadena \u00e9s una adre\u00e7a de correu electr\u00f2nic molt simple sense haver d'escriure isEmail() cada cop.  Pots crear una propietat d'extensi\u00f3 anomenada isSimpleEmail.</p>"},{"location":"Android/Kotlin/fextensio/#codi-de-la-propietat-dextensio","title":"Codi de la Propietat d'Extensi\u00f3","text":"<p>Definim la propietat d'extensi\u00f3 isSimpleEmail per al tipus String. \u00c9s de tipus Boolean i nom\u00e9s t\u00e9 un getter (\u00e9s de nom\u00e9s lectura): <pre><code>// Extensions.kt\n// Definim una propietat de nom\u00e9s lectura (val) amb un getter personalitzat\nval String.isSimpleEmail: Boolean\n    get() {\n        // En una implementaci\u00f3 real, aquesta l\u00f2gica seria molt m\u00e9s complexa (p. ex., amb expressions regulars)\n        // Per\u00f2 per a l'exemple, simplement mirem si cont\u00e9 un '@' i un '.'\n        return this.contains('@') &amp;&amp; this.contains('.')\n    }\n</code></pre></p>"},{"location":"Android/Kotlin/fextensio/#com-sutilitza","title":"Com S'Utilitza","text":"<p>Ara, pots accedir a aquesta propietat directament sobre qualsevol String com si fos un camp definit a la classe:Kotlinfun main() {     val emailCorrecte = \"usuari@exemple.com\"     val textNormal = \"Aix\u00f2 no \u00e9s un correu\"</p> <pre><code>// Accedim-hi com una propietat, sense par\u00e8ntesis!\nprintln(\"'$emailCorrecte' \u00e9s un correu: ${emailCorrecte.isSimpleEmail}\") \n// Sortida: 'usuari@exemple.com' \u00e9s un correu: true\n\nprintln(\"'$textNormal' \u00e9s un correu: ${textNormal.isSimpleEmail}\")\n// Sortida: 'Aix\u00f2 no \u00e9s un correu' \u00e9s un correu: false\n</code></pre> <p>}</p>"},{"location":"Android/Kotlin/fextensio/#5-diferencies-entre-funcio-dextensio-i","title":"5. Difer\u00e8ncies entre funci\u00f3 d'extensi\u00f3 i","text":"<p>Observeu la difer\u00e8ncia amb la funci\u00f3 d'extensi\u00f3:</p> <ul> <li>Funci\u00f3 d'Extensi\u00f3: text.capitalizeFirstLetter() $\\rightarrow$ Necessita par\u00e8ntesis.</li> <li>Propietat d'Extensi\u00f3: text.isSimpleEmail $\\rightarrow$ No necessita par\u00e8ntesis, fent que el codi sigui molt m\u00e9s clar i semblant a la lectura d'un atribut.</li> </ul>"},{"location":"Android/Kotlin/funcions/","title":"Funcions","text":""},{"location":"Android/Kotlin/funcions/#funcions-en-kotlin","title":"Funcions en kotlin","text":"<p>A part de les caracter\u00edstiques que poden tenir les funcions, com el altres llenguatges com per exemple Java, (noms, par\u00e0metres, valors per defecte, etc), Kotlin t\u00e9 les seves particularitats:</p>"},{"location":"Android/Kotlin/funcions/#funcions-compactes-single-expression","title":"Funcions compactes (single-expression)","text":"<p>Serveixen per simplificar:</p> <p>Forma completa: <pre><code>fun double(x: Int): Int {\n    return x * 2\n}\n</code></pre></p> <p>Forma compacta:</p> <pre><code>fun double(x: Int): Int = x * 2\n</code></pre>"},{"location":"Android/Kotlin/funcions/#lambdes-i-funcions-dordre-superior","title":"Lambdes i funcions d\u2019ordre superior","text":"<p>Kotlin tracta les funcions com si fossin de \"primera classe\", o \"first class\": Aix\u00f3 vol dir que:</p> <ul> <li>es poden guardar en variables</li> <li>passar com a par\u00e0metres</li> <li>retornar-les des d'altres funcions</li> </ul>"},{"location":"Android/Kotlin/funcions/#lambda","title":"Lambda","text":"<p>Una funci\u00f3 sense nom \u00e9s una funci\u00f3 lambda, en aquest cas guardada com a variable:</p> <p><pre><code>val waterFilter : (Int) -&gt; Int = { level: Int -&gt; level / 2 }\nprintln(waterFilter(20))  // 10\n</code></pre> En aquest cas la definici\u00f3 de la variables segueix les normes:</p> <p><pre><code>val variable:tipus=valor\n</code></pre> Per\u00f2 en comptes d'un tipus simple o una classe, el tipus i el valor \u00e9s una funci\u00f3. En el tipus, una firma d'una funci\u00f3, i en el valor, la implementaci\u00f3 de la funci\u00f3.</p> <p>Si no especifiquem el par\u00e0metre en una funci\u00f3 lambda i nom\u00e9s t\u00e9 un par\u00e0metre, aquest per defecte ser\u00e0 \"it\", i podem ometre el par\u00e0metre i -&gt; :</p> <pre><code>val waterFilter : (Int) -&gt; Int = { it / 2 }\n</code></pre>"},{"location":"Android/Kotlin/funcions/#funcio-dordre-superior","title":"Funci\u00f3 d\u2019ordre superior","text":"<p>Les funcions d'ordre superior s\u00f3n aquelles que reben una funci\u00f3 com a argument:</p> <pre><code>fun encodeMsg(msg: String, encode: (String) -&gt; String): String {\n    return encode(msg)\n}\n\nval upper = { s: String -&gt; s.uppercase() }\nprintln(encodeMsg(\"abc\", upper))\n</code></pre>"},{"location":"Android/Kotlin/funcions/#passar-referencia-de-funcio","title":"Passar refer\u00e8ncia de funci\u00f3","text":"<p>Amb :: podem passar la refer\u00e8ncia a una funci\u00f3.</p> <pre><code>fun enc2(input:String): String = input.reversed()\nencodeMessage(\"abc\", ::enc2)\n</code></pre>"},{"location":"Android/Kotlin/funcions/#ultim-parametre-duna-funcio","title":"\u00daltim par\u00e0metre d'una funci\u00f3","text":"<p>En Kotlin \u00e9s preferible que si hi ha algun par\u00e0metre que sigui una funci\u00f3, aquest sigui l'ultim par\u00e0metre:</p> <pre><code>encodeMessage(\"acronym\", { input -&gt; input.toUpperCase() })\n</code></pre> <p>Si la funci\u00f3 nom\u00e9s t\u00e9 un par\u00e0metre, podem ometre:</p> <p>Els par\u00e8ntesi:</p> <pre><code>val ints = listOf(1, 2, 3)\nints.filter { n: Int -&gt; n &gt; 0 }\n</code></pre> <p>El nom del par\u00e0metre i la -&gt; si nom\u00e9s n'hi ha un (ser\u00e0 it): <pre><code>ints.filter { it &gt; 0 }\n</code></pre></p>"},{"location":"Android/Kotlin/livedata/","title":"LiveData (i ViewModel):","text":""},{"location":"Android/Kotlin/livedata/#1-conceptes-fonamentals-de-livedata","title":"1. Conceptes fonamentals de LiveData","text":""},{"location":"Android/Kotlin/livedata/#que-es-livedata-i-per-que-sutilitza","title":"Qu\u00e8 \u00e9s LiveData i per qu\u00e8 s'utilitza","text":"<p>LiveData \u00e9s una classe contenidora de dades observable que forma part d'Android Jetpack.  La seva funci\u00f3 principal \u00e9s mantenir i gestionar dades que la UI necessita observar.</p>"},{"location":"Android/Kotlin/livedata/#caracteristiques-principals","title":"Caracter\u00edstiques principals:","text":"<ul> <li>Observable: Notifica autom\u00e0ticament als observadors quan les dades canvien</li> <li>Lifecycle-aware: Respecta el cicle de vida dels components d'Android</li> <li>Prev\u00e9 memory leaks: S'eliminen autom\u00e0ticament les subscripcions quan el component es destrueix</li> <li>Actualitzacions autom\u00e0tiques: La UI sempre mostra les dades m\u00e9s recents</li> </ul>"},{"location":"Android/Kotlin/livedata/#per-que-utilitzar-livedata","title":"Per qu\u00e8 utilitzar LiveData:","text":"<ul> <li>Elimina la necessitat de gestionar manualment les subscripcions</li> <li>Garanteix que la UI nom\u00e9s s'actualitzi quan est\u00e0 activa (STARTED o RESUMED)</li> <li>Evita crashes per actualitzar la UI quan l'Activity/Fragment est\u00e0 destru\u00eft</li> <li>Facilita la comunicaci\u00f3 entre ViewModel i la capa de UI</li> </ul>"},{"location":"Android/Kotlin/livedata/#2-diferencies-entre-dades-normals-i-livedatadades-normals-variables-convencionals","title":"2. Difer\u00e8ncies entre dades normals i LiveDataDades normals (variables convencionals):","text":"<p><pre><code>class  ViewModel {\n    var contador: Int = 0  // Variable normal\n\n    fun incrementar() {\n        contador++\n        // Necessites notificar manualment la UI del canvi\n    }\n}\n</code></pre> Amb LiveData: <pre><code>ViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    fun incrementar() {\n        _contador.value = _contador.value?.plus(1)\n        // La UI s'actualitza autom\u00e0ticament (veure patro observer)\n    }\n}\n</code></pre></p>"},{"location":"Android/Kotlin/livedata/#3-el-patro-observer-aplicat-a-livedata","title":"3. El patr\u00f3 Observer aplicat a LiveData","text":"<p>LiveData implementa el patr\u00f3 de disseny Observer, on:</p> <p>Variable (LiveData): Cont\u00e9 les dades i mant\u00e9 una llista d'observadors Observer (UI component): S'subscriu per rebre notificacions dels canvis</p> <p>Funcionament:</p> <p>La UI s'subscriu al LiveData utilitzant observe() Quan les dades canvien, LiveData notifica autom\u00e0ticament tots els observadors actius Els observadors reben les noves dades i actualitzen la UI</p> <p>Exemple: <pre><code>// Al ViewModel\nclass ContadorViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    fun incrementar() {\n        _contador.value = (_contador.value ?: 0) + 1\n    }\n}\n\n// A l'Activity/Fragment\nviewModel.contador.observe(viewLifecycleOwner) { nouValor -&gt;\n    // Aquest codi s'executa autom\u00e0ticament cada vegada que canvia el valor\n    textViewContador.text = nouValor.toString()\n}\n</code></pre></p>"},{"location":"Android/Kotlin/livedata/#lifecycle-awareness","title":"Lifecycle awareness:","text":"<p>Una de les caracter\u00edstiques m\u00e9s potents de LiveData \u00e9s la seva consci\u00e8ncia del cicle de vida dels components d'Android.</p> <p>La funci\u00f3 observe nom\u00e9s s'executar\u00e0 si el fragment \u00e9s visible.</p>"},{"location":"Android/Kotlin/livedata/#escenaris-practics","title":"Escenaris pr\u00e0ctics:","text":"<ul> <li>App passa a background: LiveData deixa d'enviar actualitzacions</li> <li>App torna a foreground: LiveData envia l'\u00faltima dada disponible</li> <li>Rotaci\u00f3 de pantalla: El nou Activity/Fragment rep autom\u00e0ticament l'\u00faltima dada</li> <li>Fragment destru\u00eft: L'observador s'elimina autom\u00e0ticament, no hi ha memory leaks</li> </ul> <p>Beneficis:</p> <ul> <li>No cal fer removeObserver() manualment</li> <li>No hi ha crashes per actualitzar vistes que ja no existeixen</li> <li>No es processen actualitzacions quan la UI no \u00e9s visible</li> </ul>"},{"location":"Android/Kotlin/livedata/#4-tipus-de-livedata","title":"4. Tipus de LiveData","text":""},{"location":"Android/Kotlin/livedata/#livedata-immutable-nomes-lectura","title":"LiveData immutable (nom\u00e9s lectura)","text":"<p>LiveData \u00e9s la classe base que proporciona nom\u00e9s capacitats de lectura. Els observadors poden rebre dades per\u00f2 no modificar-les directament.</p> <p>Caracter\u00edstiques:</p> <ul> <li>No t\u00e9 m\u00e8todes p\u00fablics per modificar el valor</li> <li>S'utilitza per exposar dades a la UI</li> <li>Garanteix que la UI no pugui modificar les dades del ViewModel</li> </ul> <p>Declaraci\u00f3: <pre><code>val nomUsuari: LiveData&lt;String&gt;  // Nom\u00e9s lectura\n</code></pre></p>"},{"location":"Android/Kotlin/livedata/#mutablelivedata-lectura-i-escriptura","title":"MutableLiveData (lectura i escriptura)","text":"<p>MutableLiveData \u00e9s una subclasse de LiveData que afegeix els m\u00e8todes setValue() i postValue() per modificar el valor.</p> <p>Caracter\u00edstiques:</p> <ul> <li>Permet modificar el valor de les dades</li> <li>S'utilitza internament al ViewModel</li> <li>No s'hauria d'exposar directament a la UI</li> </ul>"},{"location":"Android/Kotlin/livedata/#declaracio","title":"Declaraci\u00f3:","text":"<pre><code>private val _nomUsuari = MutableLiveData&lt;String&gt;()  // Privat i mutable\nval nomUsuari: LiveData&lt;String&gt; = _nomUsuari  // P\u00fablic i immutable\n</code></pre>"},{"location":"Android/Kotlin/livedata/#5-integracio-livedata-amb-viewmodel","title":"5. Integraci\u00f3 LiveData amb ViewModel","text":""},{"location":"Android/Kotlin/livedata/#com-declarar-livedata-dins-del-viewmodel","title":"Com declarar LiveData dins del ViewModel","text":"<p>La declaraci\u00f3 correcta de LiveData al ViewModel segueix un patr\u00f3 espec\u00edfic que garanteix l'encapsulaci\u00f3 i la separaci\u00f3 de responsabilitats.</p> <p>Patr\u00f3 recomanat:</p> <p><pre><code>class ProducteViewModel : ViewModel() {\n    // 1. Declarar MutableLiveData PRIVAT\n    private val _producte = MutableLiveData&lt;Producte&gt;()\n\n    // 2. Exposar LiveData immutable P\u00daBLIC\n    val producte: LiveData&lt;Producte&gt; = _producte\n\n    // 3. Funcions per modificar les dades\n    fun carregarProducte(id: Int) {\n        _producte.value = repositori.obtenirProducte(id)\n    }\n}\n</code></pre> Amb valors inicials: <pre><code>class ContadorViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)  // Valor inicial: 0\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    private val _nomUsuari = MutableLiveData&lt;String&gt;().apply {\n        value = \"Usuari desconegut\"  // Alternativa per valor inicial\n    }\n    val nomUsuari: LiveData&lt;String&gt; = _nomUsuari\n}\n</code></pre> Amb tipus complexos: <pre><code>data class EstatUI(\n    val carregant: Boolean = false,\n    val dades: List&lt;String&gt; = emptyList(),\n    val error: String? = null\n)\n\nclass DadesViewModel : ViewModel() {\n    private val _estat = MutableLiveData&lt;EstatUI&gt;(EstatUI())\n    val estat: LiveData&lt;EstatUI&gt; = _estat\n\n    fun carregarDades() {\n        _estat.value = EstatUI(carregant = true)\n        // ... l\u00f2gica de c\u00e0rrega\n    }\n}\n</code></pre></p> <p>Exposar LiveData immutable per\u00f2 mantenir MutableLiveData privat</p> <p>Aquest patr\u00f3 \u00e9s fonamental per mantenir l'encapsulaci\u00f3 i seguir els principis de disseny d'Android.</p> <p>Per qu\u00e8 \u00e9s important:</p> <ul> <li>Encapsulaci\u00f3: La UI no pot modificar directament les dades</li> <li>\u00danic punt de control: Nom\u00e9s el ViewModel pot canviar les dades</li> <li>Mantenibilitat: M\u00e9s f\u00e0cil de depurar i mantenir</li> <li>Testabilitat: Pots provar el ViewModel sense preocupar-te per modificacions externes</li> </ul>"},{"location":"Android/Kotlin/livedata/#6-exemple-complet-amb-multiples-livedata","title":"6. Exemple complet amb m\u00faltiples LiveData:","text":"<p><pre><code>class CarretCompraViewModel : ViewModel() {\n    // Articles del carret\n    private val _articles = MutableLiveData&lt;List&lt;Article&gt;&gt;(emptyList())\n    val articles: LiveData&lt;List&lt;Article&gt;&gt; = _articles\n\n    // Total del carret\n    private val _total = MutableLiveData&lt;Double&gt;(0.0)\n    val total: LiveData&lt;Double&gt; = _total\n\n    // Estat de c\u00e0rrega\n    private val _carregant = MutableLiveData&lt;Boolean&gt;(false)\n    val carregant: LiveData&lt;Boolean&gt; = _carregant\n\n    fun afegirArticle(article: Article) {\n        val llistaActual = _articles.value?.toMutableList() ?: mutableListOf()\n        llistaActual.add(article)\n        _articles.value = llistaActual\n        calcularTotal()\n    }\n\n    fun eliminarArticle(article: Article) {\n        val llistaActual = _articles.value?.toMutableList() ?: return\n        llistaActual.remove(article)\n        _articles.value = llistaActual\n        calcularTotal()\n    }\n\n    private fun calcularTotal() {\n        val articles = _articles.value ?: emptyList()\n        _total.value = articles.sumOf { it.preu }\n    }\n}\n</code></pre> \u00das a l'Activity/Fragment: <pre><code>class CarretActivity : AppCompatActivity() {\n    private val viewModel: CarretCompraViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // La UI nom\u00e9s pot observar, no modificar\n        viewModel.articles.observe(this) { articles -&gt;\n            actualitzarLlistaUI(articles)\n        }\n\n        viewModel.total.observe(this) { total -&gt;\n            textViewTotal.text = \"Total: $total\u20ac\"\n        }\n\n        // Les modificacions es fan a trav\u00e9s del ViewModel\n        buttonAfegir.setOnClickListener {\n            viewModel.afegirArticle(articleSeleccionat)\n        }\n    }\n}\n</code></pre></p>"},{"location":"Android/Kotlin/livedata/#separacio-entre-logica-de-negoci-i-ui","title":"Separaci\u00f3 entre l\u00f2gica de negoci i UI","text":"<p>La separaci\u00f3 adequada entre l\u00f2gica de negoci (ViewModel) i UI (Activity/Fragment) \u00e9s essencial per mantenir un codi net i mantenible.</p> <p>Responsabilitats del ViewModel:</p> <ul> <li>Mantenir i gestionar les dades de la UI</li> <li>Implementar la l\u00f2gica de negoci</li> <li>Comunicar-se amb repositoris o fonts de dades</li> <li>Processar i transformar dades</li> <li>Gestionar l'estat de l'aplicaci\u00f3</li> </ul> <p>Responsabilitats de la UI:</p> <ul> <li>Observar les dades del ViewModel</li> <li>Mostrar les dades a l'usuari</li> <li>Capturar events de l'usuari</li> <li>Cridar funcions del ViewModel en resposta a events</li> <li>Gestionar elements visuals (animacions, di\u00e0legs, etc.)</li> </ul>"},{"location":"Android/Kotlin/livedata/#referencies","title":"Refer\u00e8ncies","text":"<p>Livedata (amb viewbinding) https://cursokotlin.com/mvvm-en-android-con-kotlin-livedata-y-view-binding-android-architecture-components/</p> <p>Video de Devexperto: https://www.youtube.com/watch?v=LHBbs6QXvic</p>"},{"location":"Android/Kotlin/livedata/#codelab","title":"Codelab","text":"<p>https://developer.android.com/codelabs/basic-android-kotlin-training-livedata?hl=es-419#0</p>"},{"location":"Android/Kotlin/nullsafety/","title":"Null Safety","text":""},{"location":"Android/Kotlin/nullsafety/#variables-i-seguretat-amb-valors-nuls","title":"Variables i seguretat amb valors nuls","text":"<p>Un dels trets m\u00e9s distintius \u00e9s com gestiona els valors nuls:</p> <ul> <li>Una variable normal no pot tenir null. <pre><code>val nom: String = \"David\"\n</code></pre></li> </ul> <p>Si volem permetre valors nuls, aquell mateix tipus es converteix en un tipus diferent.</p> <ul> <li> <p>Int? \u00e9s diferent de Int</p> </li> <li> <p>String? \u00e9s diferent de String</p> </li> </ul> <pre><code>val nom: String? = null\n</code></pre> <p>En Kotlin, si una variable pot ser null, el compilador obliga el programador a gestionar el cas null abans d\u2019utilitzar-la. Aquest sistema evita molts errors freq\u00fcents en llenguatges m\u00e9s antics.</p>"},{"location":"Android/Kotlin/nullsafety/#operadors-per-gestionar-nulabilitat-de-variables","title":"Operadors per gestionar nulabilitat de variables","text":""},{"location":"Android/Kotlin/nullsafety/#operador-dacces-segur","title":"Operador d\u2019acc\u00e9s segur ?.","text":"<p>Serveix per accedir a una propietat o funci\u00f3 nom\u00e9s quan el valor no \u00e9s null.</p> <pre><code>val nom: String? = \"David\"\nprintln(nom?.length)\n</code></pre> <p>Tamb\u00e9 el compilador sap si hem comprovat la nullabilitat: <pre><code>val nom: String? = \"David\"\nif (nom != null){\n    println(nom.length)\n}\n</code></pre> En aquest cas, no cal utilitzar l'operador ?.</p>"},{"location":"Android/Kotlin/nullsafety/#operador-elvis","title":"Operador Elvis ?:","text":"<p>Permet donar un valor alternatiu quan la variable \u00e9s null. <pre><code>val nom: String? = null\nval resultat = nom ?: \"Desconegut\"\nprintln(resultat)\n</code></pre></p>"},{"location":"Android/Kotlin/nullsafety/#operador-de-no-null-forcat","title":"Operador de no-null for\u00e7at !!","text":"<p>\u00c9s com dir: \"estic segur que no \u00e9s null\", (o capturar l'excepci\u00f3 si ho \u00e9s).</p> <pre><code>val nom: String? = null\nprintln(nom!!.length) // Error en execuci\u00f3!\n</code></pre> <ul> <li>Si la variable \u00e9s null \u2192 el programa falla.</li> <li>Nom\u00e9s s\u2019ha d\u2019utilitzar si es t\u00e9 la certesa que no ser\u00e0 null.</li> </ul>"},{"location":"Android/Kotlin/nullsafety/#funcio-let-combinada-amb","title":"Funci\u00f3 let combinada amb ?.","text":"<p>S\u2019executa el bloc nom\u00e9s si el valor no \u00e9s null. <pre><code>val nom: String? = \"David\"\nnom?.let {\n    println(\"El nom t\u00e9 ${it.length} lletres\")\n}\n</code></pre></p>"},{"location":"Android/Kotlin/variables/","title":"Variables i Constants","text":"<p>## Variebles en Kotlin</p> <p>Existeixen dues formes principals de declarar variables</p> <p>Kotlin diferencia clarament entre variables que poden canviar el seu contingut i variables que no.</p>"},{"location":"Android/Kotlin/variables/#declaracio","title":"Declaraci\u00f3","text":""},{"location":"Android/Kotlin/variables/#val-variables-inmutables","title":"val \u2013 Variables inmutables","text":"<ul> <li>Representen valors constants o no modificables.</li> <li>Un cop assignades, no es poden canviar.</li> <li>Equivaldria a una constant o a una variable final en altres llenguatges.</li> <li>S\u00f3n recomanades per defecte perqu\u00e8 fan el codi m\u00e9s segur i previsible.</li> </ul>"},{"location":"Android/Kotlin/variables/#var-variables-mutables","title":"var \u2013 Variables mutables","text":"<ul> <li>Es poden modificar despr\u00e9s de declarar-les.</li> <li>S\u2019utilitzen quan el valor realment ha de canviar amb el temps.</li> <li>L\u2019\u00fas de var \u00e9s \u00fatil, per\u00f2 no abusiu; Kotlin fomenta l\u2019immutabilitat sempre que sigui possible.</li> </ul>"},{"location":"Android/Kotlin/variables/#tipus-explicits-o-implicits","title":"Tipus expl\u00edcits o impl\u00edcits","text":"<p>Kotlin \u00e9s un llenguatge fortament tipat.</p> <p>Kotlin permet indicar el tipus de la variable, per\u00f2 no sempre \u00e9s necessari.</p> <p>Gr\u00e0cies a la infer\u00e8ncia de tipus, el compilador pot deduir quin tipus \u00e9s segons el valor assignat.</p> <p>Tot i aix\u00f2, els tipus existeixen i s\u00f3n importants: </p>"},{"location":"Android/Kotlin/variables/#condicionals-if-com-expressio","title":"Condicionals (if com expressi\u00f3)","text":"<p>les sentencies if, when poden retornar valors <pre><code>val edat = 20\nval missatge = if (edat &gt;= 18) \"Major d'edat\" else \"Menor d'edat\"\n\nprintln(missatge)\n</code></pre></p> <p>La variable missatge obt\u00e9 directament un resultat. </p> <p>No cal declarar primer la variable i despr\u00e9s assignar un valor.</p>"},{"location":"Android/Llibreries/","title":"Llibreries","text":""},{"location":"Android/Llibreries/#arxiu-gradle","title":"Arxiu Gradle","text":""},{"location":"Android/Llibreries/#format-toml","title":"Format toml","text":"<p>Continguts:</p> <ul> <li>Retrofit</li> </ul>"},{"location":"Android/Llibreries/retrofit/","title":"Llibreria Retrofit","text":""},{"location":"Android/Llibreries/retrofit/#1-que-es","title":"1. Qu\u00e8 \u00e9s","text":"<ul> <li>Retrofit \u00e9s una llibreria de client HTTP de tipus segur per a Java i Kotlin desenvolupada per Square. </li> <li>Simplifica dr\u00e0sticament la connexi\u00f3 a APIs REST, </li> <li>Permet serialitzar i deserialitzar autom\u00e0ticament objectes Kotlin/Java a JSON (o XML, etc.) i viceversa, mitjan\u00e7ant Converter Factories (com Gson, Moshi, kotlinx.serialization).</li> </ul> <p>Exemple retrofit. https://github.com/davidfs-itic/RecyclerView</p> <p>Explicaci\u00f3 pas a pas Retrofit: https://www.youtube.com/watch?v=2_DnhfQrwXQ</p>"},{"location":"Android/Llibreries/retrofit/#2-setup-dependencies","title":"2. Setup depend\u00e8ncies","text":"<p>Cal acc\u00e9s a internet des de l'aplicaci\u00f3: (AndroidManifest.xml) <pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre></p> <p>Afegir depend\u00e8ncies en el build.gradle (nivell aplicaci\u00f3)</p> <p>De forma tradicional, present en molta documentaci\u00f3: (ens demanar\u00e0 si volem transformar-la a format libs.version.toml)</p> <pre><code>// Retrofit Core\nimplementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n// Converter per gestionar JSON (Generalment es fa servir GSON)\nimplementation(\"com.squareup.retrofit2:converter-gson:2.9.0\")\n// (Opcional) Interceptor per poder veure els logs de les peticions (molt \u00fatil per a debug)\nimplementation(\"com.squareup.okhttp3:logging-interceptor:4.12.0\")\n</code></pre> <p>o amb la nova versio, anar a libs.version.toml: <pre><code>[versions]\nretrofit= \"2.9.0\"\nconverter-gson = \"2.9.0\"\n[libraries]\nrretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nconverter-gson= { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"converter-gson\" }\n</code></pre></p> <p>i finalment a dependencies del build.gradle, amb una sint\u00e0xi diferent:</p> <pre><code>dependencies {\n    // retrofit\n    implementation(libs.retrofit)\n    // gson converter\n    implementation (libs.converter.gson)\n</code></pre>"},{"location":"Android/Llibreries/retrofit/#3-implementacio","title":"3. Implementaci\u00f3","text":"<p>Creem el servei Retrofit, en un arxiu ItemsService:</p> <pre><code>interface ItemsService {\n\n@GET (\"items/\")\nsuspend fun LlistaItems():Response&lt;List&lt;Item&gt;&gt;\n}\n\n@GET (\"items/categoria/{idcategoria}\")\nsuspend fun LlistaItemsPerCategoria ( @Path(\"idcategoria\") idcagegoria:Int):Response&lt;List&lt;Item&gt;&gt;\n}\n</code></pre> <pre><code>class ItemAPI {\n    companion object {\n        private var mItemAPI : ItemService? = null\n\n        // L'anotador per a que sigui thread-safe\n        // Garanteix que nom\u00e9s un fil pugui crear la inst\u00e0ncia per evitar problemes\n        @Synchronized\n        fun API(): ItemService {\n            if (mItemAPI == null){\n\n                // 2. Configuraci\u00f3 de Gson per al format de data ISO\n                val gsondateformat = GsonBuilder()\n                    .setDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\") // Format t\u00edpic per a dates i hores\n                    .create();\n\n                // 3. Creaci\u00f3 de la inst\u00e0ncia Retrofit\n                mItemAPI = Retrofit.Builder()\n                    .addConverterFactory(GsonConverterFactory.create(gsondateformat))\n                    .baseUrl(\"https://oracleitic.mooo.com\") // URL base del teu servei d'Items\n                    .build()\n                    // 4. Creaci\u00f3 de la implementaci\u00f3 de la interf\u00edcie ItemService\n                    .create(ItemService::class.java)\n            }\n            return mItemAPI!!\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Llibreries/retrofit/#4-altra-informacio","title":"4. Altra informaci\u00f3","text":"<p>Veure Kotlin/Anotadors</p> <p>Veure Kotlin/Corrutines</p> <p>RETROFIT 2 AVANZADO en KOTLIN - (POST, GET, MULTIPART, HEADER...) - Android Studio 2022</p>"},{"location":"Arduino/","title":"Arduino","text":"<p>(!Per Fer)</p>"},{"location":"Exemples/","title":"Adreces de github amb exemples","text":""},{"location":"Exemples/#1-menus","title":"1. Men\u00fas","text":"<p>https://github.com/davidfs-itic/menus</p>"},{"location":"Exemples/#2-recycler-view","title":"2. Recycler view","text":"<p>https://github.com/davidfs-itic/RecyclerView</p>"},{"location":"Exemples/#2-rollingdiceclean","title":"2. RollingDiceClean","text":"<p>https://github.com/davidfs-itic/RollingDiceClean</p>"},{"location":"IoT/","title":"IoT","text":"<p>(!Per Fer)</p>"},{"location":"Unity/recveu/","title":"Reconeixment de veu amb Unity","text":"<p>https://www.youtube.com/watch?v=zGnhZX08k24</p>"}]}