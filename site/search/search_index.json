{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3 M\u00f2dul Android-Interf\u00edcies i Arduino","text":""},{"location":"#contingut","title":"Contingut","text":"<ul> <li>Android</li> <li> <p>Exemples de codi Android</p> </li> <li> <p>Arduino</p> </li> <li>Refer\u00e8ncies </li> </ul>"},{"location":"Android/","title":"Introducci\u00f3 a Android","text":"<p>Si seguim les indicacions de google i de molts altres desenvolupadors, veurem que qualsevol aplicaci\u00f3 ha d'estar estructurada per \"capes\", o funcionalitats separades. Vegeu com a refer\u00e8ncia aquest document:  https://developer.android.com/topic/architecture</p> <p>Elements de l'arquitectura: - VieweBinding: Android/Arquitectura/viewbinding.md - ViewModel: Android/Arquitectura/viewmodel.md - LiveData: Android/Arquitectura/livedata.md - Repositori: Android/Arquitectura/repositori.md</p>"},{"location":"Android/activities/","title":"Activi    ties","text":""},{"location":"Android/fragments/","title":"Fragments","text":"<p>Documentaci\u00f3 oficial</p> <ul> <li>https://developer.android.com/guide/fragments</li> </ul> <p>Exemple pas a pas - https://cursokotlin.com/capitulo-22-fragments-en-kotlin/</p>"},{"location":"Android/fragments/#1-introduccio-als-fragments-que-son-i-per-que-utilitzar-los","title":"1-Introducci\u00f3 als Fragments Qu\u00e8 s\u00f3n i per qu\u00e8 utilitzar-los?","text":"<p>Definici\u00f3: Components reutilitzables d'UI que representen una part d'una pantalla dins d'una Activity. Cada fragment t\u00e9 el seu cicle de vida. Han d'existir dins d'una activity o un altre fragment.</p> <p>Avantatges:</p> <ul> <li> <p>Reutilitzaci\u00f3: El mateix fragment pot usar-se en m\u00faltiples activities</p> </li> <li> <p>Disseny adaptable: Diferents layouts per m\u00f2bils/tablets</p> </li> <li> <p>Modularitat: Divideix la UI en components independents</p> </li> <li> <p>Comparaci\u00f3: Els fragments s\u00f3n com \"sub-activitats\" amb cicle de vida propi</p> </li> </ul> <p>Mostra visual d'una activity amb 2 fragments: </p>"},{"location":"Android/fragments/#2-anatomia-dun-fragment","title":"2-Anatomia d'un Fragment","text":""},{"location":"Android/fragments/#estructura-basica","title":"Estructura b\u00e0sica","text":"<p>Els fragments tenen layouts igual que les activities, en xml.</p> <p>Tamb\u00e9 tenen la seva classe Fragment() de la qual herata i sobreescriu m\u00e8todes clau</p> <pre><code>class NewFragment : Fragment() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n    }\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_blank, container, false)\n    }\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        val someInt = requireArguments().getInt(\"some_int\")\n        ...\n    }    \n</code></pre>"},{"location":"Android/fragments/#metodes-essencials","title":"M\u00e8todes essencials:","text":"<ul> <li> <p>onCreateView(): Infla el layout i retorna la View</p> </li> <li> <p>onViewCreated(): Configura les vistes un cop creades</p> </li> </ul>"},{"location":"Android/fragments/#cicle-de-vida-del-fragment","title":"Cicle de vida del Fragment","text":"<p>Punt important: onDestroyView() es crida abans que onDestroy(), alliberant la vista</p> <p>Refer\u00e8ncia: Cicle de vida dels Fragments: https://developer.android.com/guide/fragments/lifecycle</p>"},{"location":"Android/fragments/#3-implementacio-basica","title":"3-Implementaci\u00f3 B\u00e0sica","text":""},{"location":"Android/fragments/#afegir-fragments-a-una-activity","title":"Afegir fragments a una Activity","text":"<p>M\u00e8tode est\u00e0tic: Via XML amb etiqueta (per fragments fixos)</p> <pre><code>&lt;androidx.fragment.app.FragmentContainerView\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/fragmentContainerView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" /&gt;\n</code></pre> <p>M\u00e8tode din\u00e0mic: Via FragmentManager i FragmentTransaction (m\u00e9s flexible)</p>"},{"location":"Android/fragments/#fragmentmanager-i-fragmenttransaction","title":"FragmentManager i FragmentTransaction","text":"<p>Refer\u00e8ncies: https://developer.android.com/guide/fragments/fragmentmanager</p> <p>El fragmentmanager \u00e9s la classe responsable d'afegir, eliminar i la resta d'accions sobre un fragment. Al fragmentmanager hi accedim des de l'activity a trav\u00e9s de la funci\u00f3 supportFragmentManager</p> <p>Des del fragment, podem accedir al fragmentmanager de la app, amb la funci\u00f3 getParentFragmentManager()</p> <p></p>"},{"location":"Android/fragments/#afegir-fragment-a-un-fragmentcontainer","title":"Afegir fragment a un fragmentcontainer","text":"<p>Hi ha 2 maneres, afegint el fragment a l'stack, o reempla\u00e7ant-lo</p> <p>Back Stack: Permet tornar enrrere per tota la pila (stack) de fragments afegits. Replace: Substitueix la pila anterior per un altre. Nom\u00e9s es pot tornar al fragment substituit.</p> <p></p> <pre><code>    //Afegeix el fragment i l'afegeix a la pila (backstack)\n    // de manera que tornar enrrere, tornara al fragment anterior.\n    private fun addFragment(fragment: Fragment,args : Bundle?) {\n        fragment.arguments = args\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.fragmentbottom, fragment)\n        fragmentTransaction.addToBackStack(null)\n        fragmentTransaction.commit()\n    }\n    //Intercanvia el fragment. Tornar enrrere no tornara al fragment anterior.\n    private fun replaceFragment(fragment: Fragment,args : Bundle?){\n        fragment.arguments = args\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.replace(R.id.fragmentbottom, fragment)\n        fragmentTransaction.commit()\n    }\n</code></pre> <p>Amb la versi\u00f3 m\u00e9s moderna (segons la documentaci\u00f3 de android)</p> <p>Cal afegir les dependiencies:</p> <pre><code>dependencies {\n    implementation \"androidx.fragment:fragment-ktx:1.6.2\"\n    // o la versi\u00f3 m\u00e9s recent disponible\n}\n</code></pre> <p>i el codi es transforma en el seg\u00fcent:</p> <pre><code>private fun addFragment(fragment: Fragment, args: Bundle?) {\n    supportFragmentManager.commit {\n        setReorderingAllowed(true)\n        add(R.id.fragmentbottom, fragment::class.java, args)\n        addToBackStack(null)\n    }\n}\n</code></pre>"},{"location":"Android/fragments/#4-comunicacio","title":"4-Comunicaci\u00f3","text":""},{"location":"Android/fragments/#accedir-a-lactivity-des-del-fragment","title":"Accedir a l'Activity des del Fragment","text":"<p>De vegades necessitem accedir a l'activity, per exemple si necessitem modificar la appbar o toolbar.</p> <pre><code>// Forma segura - llan\u00e7a excepci\u00f3 si no hi ha activity\nval activity = requireActivity()\n\n// Forma nullable - retorna null si no hi ha activity  \nval activity = activity\n\n// Modificar Toolbar\n(requireActivity() as AppCompatActivity).supportActionBar?.title = \"Nou T\u00edtol\"\n</code></pre>"},{"location":"Android/fragments/#patro-de-callbacks","title":"Patr\u00f3 de Callbacks","text":"<pre><code>// 1. Definir interf\u00edcie al Fragment\ninterface OnButtonClickListener {\n    fun onButtonClicked(data: String)\n}\n\n// 2. Activity implementa la interf\u00edcie\n// 3. Fragment captura la refer\u00e8ncia a onAttach()\n</code></pre> <p>Vantatge: Desacobla el fragment de l'activity espec\u00edfica</p>"},{"location":"Android/fragments/#5-animacio-de-les-transicions-entre-fragments","title":"5-Animaci\u00f3 de les transicions entre fragments","text":"<p>Podem definir les animacions a la carpeta res/anim (tipus anim)</p> <p>Arxius:</p> <p>fade_out.xml</p> <pre><code>&lt;!-- res/anim/fade_out.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:interpolator=\"@android:anim/decelerate_interpolator\"\n    android:fromAlpha=\"1\"\n    android:toAlpha=\"0\" /&gt;\n</code></pre> <p>fade_in.xml</p> <pre><code>&lt;!-- res/anim/slide_in.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:interpolator=\"@android:anim/decelerate_interpolator\"\n    android:fromXDelta=\"100%\"\n    android:toXDelta=\"0%\" /&gt;\n</code></pre> <p>En la transacci\u00f3 que intercanvia els fragments</p> <pre><code>        fragmentTransaction.setCustomAnimations(\n            R.anim.fade_out, // exit\n            R.anim.fade_in, // popEnter\n        )\n</code></pre>"},{"location":"Android/fragments/#definir-la-animacio-en-entrar-o-sortir-en-el-oncreate","title":"Definir la animacio en entrar o sortir en el onCreate","text":"<p>Es creen els arxius en la carpeta res/transition (type transition)</p> <p>Arxiu fade.xml</p> <pre><code>&lt;!-- res/transition/fade.xml --&gt;\n&lt;fade xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"/&gt;\n</code></pre> <p>Arxiu slide.xml</p> <pre><code>&lt;slide xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"@android:integer/config_shortAnimTime\"\n    android:slideEdge=\"right\" /&gt;\n</code></pre> <p>en els fragments:</p> <pre><code>class FragmentA : Fragment() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val inflater = TransitionInflater.from(requireContext())\n        exitTransition = inflater.inflateTransition(R.transition.fade)\n    }\n}\n\nclass FragmentB : Fragment() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val inflater = TransitionInflater.from(requireContext())\n        enterTransition = inflater.inflateTransition(R.transition.slide_right)\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/","title":"Arquitectura","text":"<p>Si seguim les indicacions de google i de molts altres desenvolupadors, veurem que qualsevol aplicaci\u00f3 ha d'estar estructurada per \"capes\", o funcionalitats separades. Vegeu com a refer\u00e8ncia aquest document: https://developer.android.com/topic/architecture</p>"},{"location":"Android/Arquitectura/livedata/","title":"LiveData (i ViewModel):","text":""},{"location":"Android/Arquitectura/livedata/#1-conceptes-fonamentals-de-livedata","title":"1. Conceptes fonamentals de LiveData","text":""},{"location":"Android/Arquitectura/livedata/#que-es-livedata-i-per-que-sutilitza","title":"Qu\u00e8 \u00e9s LiveData i per qu\u00e8 s'utilitza","text":"<p>LiveData \u00e9s una classe contenidora de dades observable que forma part d'Android Jetpack.  La seva funci\u00f3 principal \u00e9s mantenir i gestionar dades que la UI necessita observar.</p>"},{"location":"Android/Arquitectura/livedata/#caracteristiques-principals","title":"Caracter\u00edstiques principals:","text":"<ul> <li>Observable: Notifica autom\u00e0ticament als observadors quan les dades canvien</li> <li>Lifecycle-aware: Respecta el cicle de vida dels components d'Android</li> <li>Prev\u00e9 memory leaks: S'eliminen autom\u00e0ticament les subscripcions quan el component es destrueix</li> <li>Actualitzacions autom\u00e0tiques: La UI sempre mostra les dades m\u00e9s recents</li> </ul>"},{"location":"Android/Arquitectura/livedata/#per-que-utilitzar-livedata","title":"Per qu\u00e8 utilitzar LiveData:","text":"<ul> <li>Elimina la necessitat de gestionar manualment les subscripcions</li> <li>Garanteix que la UI nom\u00e9s s'actualitzi quan est\u00e0 activa (STARTED o RESUMED)</li> <li>Evita crashes per actualitzar la UI quan l'Activity/Fragment est\u00e0 destru\u00eft</li> <li>Facilita la comunicaci\u00f3 entre ViewModel i la capa de UI</li> </ul>"},{"location":"Android/Arquitectura/livedata/#2-diferencies-entre-dades-normals-i-livedatadades-normals-variables-convencionals","title":"2. Difer\u00e8ncies entre dades normals i LiveDataDades normals (variables convencionals):","text":"<pre><code>class  ViewModel {\n    var contador: Int = 0  // Variable normal\n\n    fun incrementar() {\n        contador++\n        // Necessites notificar manualment la UI del canvi\n    }\n}\n</code></pre> <p>Amb LiveData:</p> <pre><code>ViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    fun incrementar() {\n        _contador.value = _contador.value?.plus(1)\n        // La UI s'actualitza autom\u00e0ticament (veure patro observer)\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/livedata/#3-el-patro-observer-aplicat-a-livedata","title":"3. El patr\u00f3 Observer aplicat a LiveData","text":"<p>LiveData implementa el patr\u00f3 de disseny Observer, on:</p> <p>Variable (LiveData): Cont\u00e9 les dades i mant\u00e9 una llista d'observadors Observer (UI component): S'subscriu per rebre notificacions dels canvis</p> <p>Funcionament:</p> <p>La UI s'subscriu al LiveData utilitzant observe() Quan les dades canvien, LiveData notifica autom\u00e0ticament tots els observadors actius Els observadors reben les noves dades i actualitzen la UI</p> <p>Exemple:</p> <pre><code>// Al ViewModel\nclass ContadorViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    fun incrementar() {\n        _contador.value = (_contador.value ?: 0) + 1\n    }\n}\n\n// A l'Activity/Fragment\nviewModel.contador.observe(viewLifecycleOwner) { nouValor -&gt;\n    // Aquest codi s'executa autom\u00e0ticament cada vegada que canvia el valor\n    textViewContador.text = nouValor.toString()\n}\n</code></pre>"},{"location":"Android/Arquitectura/livedata/#lifecycle-awareness","title":"Lifecycle awareness:","text":"<p>Una de les caracter\u00edstiques m\u00e9s potents de LiveData \u00e9s la seva consci\u00e8ncia del cicle de vida dels components d'Android.</p> <p>La funci\u00f3 observe nom\u00e9s s'executar\u00e0 si el fragment \u00e9s visible.</p>"},{"location":"Android/Arquitectura/livedata/#escenaris-practics","title":"Escenaris pr\u00e0ctics:","text":"<ul> <li>App passa a background: LiveData deixa d'enviar actualitzacions</li> <li>App torna a foreground: LiveData envia l'\u00faltima dada disponible</li> <li>Rotaci\u00f3 de pantalla: El nou Activity/Fragment rep autom\u00e0ticament l'\u00faltima dada</li> <li>Fragment destru\u00eft: L'observador s'elimina autom\u00e0ticament, no hi ha memory leaks</li> </ul> <p>Beneficis:</p> <ul> <li>No cal fer removeObserver() manualment</li> <li>No hi ha crashes per actualitzar vistes que ja no existeixen</li> <li>No es processen actualitzacions quan la UI no \u00e9s visible</li> </ul>"},{"location":"Android/Arquitectura/livedata/#4-tipus-de-livedata","title":"4. Tipus de LiveData","text":""},{"location":"Android/Arquitectura/livedata/#livedata-immutable-nomes-lectura","title":"LiveData immutable (nom\u00e9s lectura)","text":"<p>LiveData \u00e9s la classe base que proporciona nom\u00e9s capacitats de lectura. Els observadors poden rebre dades per\u00f2 no modificar-les directament.</p> <p>Caracter\u00edstiques:</p> <ul> <li>No t\u00e9 m\u00e8todes p\u00fablics per modificar el valor</li> <li>S'utilitza per exposar dades a la UI</li> <li>Garanteix que la UI no pugui modificar les dades del ViewModel</li> </ul> <p>Declaraci\u00f3:</p> <pre><code>val nomUsuari: LiveData&lt;String&gt;  // Nom\u00e9s lectura\n</code></pre>"},{"location":"Android/Arquitectura/livedata/#mutablelivedata-lectura-i-escriptura","title":"MutableLiveData (lectura i escriptura)","text":"<p>MutableLiveData \u00e9s una subclasse de LiveData que afegeix els m\u00e8todes setValue() i postValue() per modificar el valor.</p> <p>Caracter\u00edstiques:</p> <ul> <li>Permet modificar el valor de les dades</li> <li>S'utilitza internament al ViewModel</li> <li>No s'hauria d'exposar directament a la UI</li> </ul>"},{"location":"Android/Arquitectura/livedata/#declaracio","title":"Declaraci\u00f3:","text":"<pre><code>private val _nomUsuari = MutableLiveData&lt;String&gt;()  // Privat i mutable\nval nomUsuari: LiveData&lt;String&gt; = _nomUsuari  // P\u00fablic i immutable\n</code></pre>"},{"location":"Android/Arquitectura/livedata/#5-integracio-livedata-amb-viewmodel","title":"5. Integraci\u00f3 LiveData amb ViewModel","text":""},{"location":"Android/Arquitectura/livedata/#com-declarar-livedata-dins-del-viewmodel","title":"Com declarar LiveData dins del ViewModel","text":"<p>La declaraci\u00f3 correcta de LiveData al ViewModel segueix un patr\u00f3 espec\u00edfic que garanteix l'encapsulaci\u00f3 i la separaci\u00f3 de responsabilitats.</p> <p>Patr\u00f3 recomanat:</p> <pre><code>class ProducteViewModel : ViewModel() {\n    // 1. Declarar MutableLiveData PRIVAT\n    private val _producte = MutableLiveData&lt;Producte&gt;()\n\n    // 2. Exposar LiveData immutable P\u00daBLIC\n    val producte: LiveData&lt;Producte&gt; = _producte\n\n    // 3. Funcions per modificar les dades\n    fun carregarProducte(id: Int) {\n        _producte.value = repositori.obtenirProducte(id)\n    }\n}\n</code></pre> <p>Amb valors inicials:</p> <pre><code>class ContadorViewModel : ViewModel() {\n    private val _contador = MutableLiveData&lt;Int&gt;(0)  // Valor inicial: 0\n    val contador: LiveData&lt;Int&gt; = _contador\n\n    private val _nomUsuari = MutableLiveData&lt;String&gt;().apply {\n        value = \"Usuari desconegut\"  // Alternativa per valor inicial\n    }\n    val nomUsuari: LiveData&lt;String&gt; = _nomUsuari\n}\n</code></pre> <p>Amb tipus complexos:</p> <pre><code>data class EstatUI(\n    val carregant: Boolean = false,\n    val dades: List&lt;String&gt; = emptyList(),\n    val error: String? = null\n)\n\nclass DadesViewModel : ViewModel() {\n    private val _estat = MutableLiveData&lt;EstatUI&gt;(EstatUI())\n    val estat: LiveData&lt;EstatUI&gt; = _estat\n\n    fun carregarDades() {\n        _estat.value = EstatUI(carregant = true)\n        // ... l\u00f2gica de c\u00e0rrega\n    }\n}\n</code></pre> <p>Exposar LiveData immutable per\u00f2 mantenir MutableLiveData privat</p> <p>Aquest patr\u00f3 \u00e9s fonamental per mantenir l'encapsulaci\u00f3 i seguir els principis de disseny d'Android.</p> <p>Per qu\u00e8 \u00e9s important:</p> <ul> <li>Encapsulaci\u00f3: La UI no pot modificar directament les dades</li> <li>\u00danic punt de control: Nom\u00e9s el ViewModel pot canviar les dades</li> <li>Mantenibilitat: M\u00e9s f\u00e0cil de depurar i mantenir</li> <li>Testabilitat: Pots provar el ViewModel sense preocupar-te per modificacions externes</li> </ul>"},{"location":"Android/Arquitectura/livedata/#6-exemple-complet-amb-multiples-livedata","title":"6. Exemple complet amb m\u00faltiples LiveData:","text":"<pre><code>class CarretCompraViewModel : ViewModel() {\n    // Articles del carret\n    private val _articles = MutableLiveData&lt;List&lt;Article&gt;&gt;(emptyList())\n    val articles: LiveData&lt;List&lt;Article&gt;&gt; = _articles\n\n    // Total del carret\n    private val _total = MutableLiveData&lt;Double&gt;(0.0)\n    val total: LiveData&lt;Double&gt; = _total\n\n    // Estat de c\u00e0rrega\n    private val _carregant = MutableLiveData&lt;Boolean&gt;(false)\n    val carregant: LiveData&lt;Boolean&gt; = _carregant\n\n    fun afegirArticle(article: Article) {\n        val llistaActual = _articles.value?.toMutableList() ?: mutableListOf()\n        llistaActual.add(article)\n        _articles.value = llistaActual\n        calcularTotal()\n    }\n\n    fun eliminarArticle(article: Article) {\n        val llistaActual = _articles.value?.toMutableList() ?: return\n        llistaActual.remove(article)\n        _articles.value = llistaActual\n        calcularTotal()\n    }\n\n    private fun calcularTotal() {\n        val articles = _articles.value ?: emptyList()\n        _total.value = articles.sumOf { it.preu }\n    }\n}\n</code></pre> <p>\u00das a l'Activity/Fragment:</p> <pre><code>class CarretActivity : AppCompatActivity() {\n    private val viewModel: CarretCompraViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // La UI nom\u00e9s pot observar, no modificar\n        viewModel.articles.observe(this) { articles -&gt;\n            actualitzarLlistaUI(articles)\n        }\n\n        viewModel.total.observe(this) { total -&gt;\n            textViewTotal.text = \"Total: $total\u20ac\"\n        }\n\n        // Les modificacions es fan a trav\u00e9s del ViewModel\n        buttonAfegir.setOnClickListener {\n            viewModel.afegirArticle(articleSeleccionat)\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/livedata/#separacio-entre-logica-de-negoci-i-ui","title":"Separaci\u00f3 entre l\u00f2gica de negoci i UI","text":"<p>La separaci\u00f3 adequada entre l\u00f2gica de negoci (ViewModel) i UI (Activity/Fragment) \u00e9s essencial per mantenir un codi net i mantenible.</p> <p>Responsabilitats del ViewModel:</p> <ul> <li>Mantenir i gestionar les dades de la UI</li> <li>Implementar la l\u00f2gica de negoci</li> <li>Comunicar-se amb repositoris o fonts de dades</li> <li>Processar i transformar dades</li> <li>Gestionar l'estat de l'aplicaci\u00f3</li> </ul> <p>Responsabilitats de la UI:</p> <ul> <li>Observar les dades del ViewModel</li> <li>Mostrar les dades a l'usuari</li> <li>Capturar events de l'usuari</li> <li>Cridar funcions del ViewModel en resposta a events</li> <li>Gestionar elements visuals (animacions, di\u00e0legs, etc.)</li> </ul>"},{"location":"Android/Arquitectura/livedata/#referencies","title":"Refer\u00e8ncies","text":"<p>Livedata (amb viewbinding) https://cursokotlin.com/mvvm-en-android-con-kotlin-livedata-y-view-binding-android-architecture-components/</p> <p>Video de Devexperto: https://www.youtube.com/watch?v=LHBbs6QXvic</p>"},{"location":"Android/Arquitectura/livedata/#codelab","title":"Codelab","text":"<p>https://developer.android.com/codelabs/basic-android-kotlin-training-livedata?hl=es-419#0</p>"},{"location":"Android/Arquitectura/repositori/","title":"Capa repositori i dades","text":""},{"location":"Android/Arquitectura/viewbinding/","title":"Viewbinding","text":"<p>https://developer.android.com/topic/libraries/view-binding</p> <p>El viewbinding \u00e9s una caracter\u00edstica (feature) que ens permet accedir als objectes que hi ha en una vista, directament sense haver de buscar-lo amb el findviewbyid</p> <p>S'activa d'aquesta manera, en el build.grade de nivell de m\u00f2dul</p> <pre><code>android {\n    ...\n    buildFeatures {\n        viewBinding = true\n    }\n}\n</code></pre> <p>El que far\u00e0 aquesta caracter\u00edstica, \u00e9s generar, per cada layout, una classe amb el nom del layout+binding, per exemple  per al layout activity_main es far\u00e0 la classe ActivityMainBinding  Aquesta classe, contindr\u00e0 tantes properties com elements visuals hi hagi en el layout, per exemple botons, textboxes, etc.</p> <p>Tamb\u00e9 t\u00e9 un m\u00e9tode getRoot() (o en kotlin, directament root) que accedeix al layout principal que cont\u00e9 la resta de la vista (linear o constraint layout)</p> <p>Per utilitzar-la, cal - Crear una variable d'aquest tipus (amb lateinit) - Crear la inst\u00e0ncia de la classe amb el m\u00e9tode static inflate() que crear\u00e0 l'objecte amb les properties necess\u00e0ries lligades als objectes que va creant del layout. - Utilitzar el setContentView() per a que l'activity es renderitzi a partir dels objectes creats.</p> <p>Exemple</p> <pre><code>private lateinit var binding: ActivityMainBinding\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    binding = ActivityMainBinding.inflate(layoutInflater)\n    setContentView(binding.root)\n}\n</code></pre> <p>A partir d'aqu\u00ed, es pot accedir als elements de la UI directament sense el findviewbyId</p> <pre><code>binding.mainTxt.setText(\"Login\")\n\nbinding.btnLogin.setOnClickListener({\n    doLogin()\n})\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/","title":"Viewmodel","text":"<p>Documentaci\u00f3 oficial: https://developer.android.com/topic/libraries/architecture/viewmodel</p>"},{"location":"Android/Arquitectura/viewmodel/#informacio-viewmodel-i-livedata","title":"Informaci\u00f3 Viewmodel i livedata","text":"<p>View model \u00e9s una arquitectura que permet separar la l\u00f2gica de la activity, de l'activity mateixa.</p> <p>La separaci\u00f3 \u00e9s important, perque s'ent\u00e9n que una activity no hauria de saber (no s'hi hauria d'implementar) quines dades </p>"},{"location":"Android/Arquitectura/viewmodel/#1-conceptes-basics","title":"1-Conceptes b\u00e0sics","text":""},{"location":"Android/Arquitectura/viewmodel/#que-es-i-per-que-existeix-separacio-de-logica-i-ui","title":"Qu\u00e8 \u00e9s i per qu\u00e8 existeix (separaci\u00f3 de l\u00f2gica i UI)","text":"<p>El ViewModel \u00e9s un component d'arquitectura dissenyat per emmagatzemar i gestionar dades relacionades amb la UI de manera conscient del cicle de vida. Per qu\u00e8 existeix:</p> <ul> <li>Separaci\u00f3 de responsabilitats: La l\u00f2gica de negoci i les dades estan separades de la UI (Activity/Fragment) -Testabilitat: Pots testejar la l\u00f2gica sense necessitat de components d'Android</li> <li>Reutilitzaci\u00f3: Diversos Fragments poden compartir el mateix ViewModel</li> <li>Persist\u00e8ncia: Les dades sobreviuen a canvis de configuraci\u00f3</li> </ul>"},{"location":"Android/Arquitectura/viewmodel/#sense-viewmodel","title":"Sense ViewModel:","text":"<pre><code>class MainActivity : AppCompatActivity() {\n    private var counter = 0 // Es perd en rotar la pantalla\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // L\u00f2gica barrejada amb codi de UI\n        button.setOnClickListener {\n            counter++\n            textView.text = counter.toString()\n            // Crides a API, c\u00e0lculs, etc...\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#amb-viewmodel","title":"Amb ViewModel:","text":"<pre><code>class CounterViewModel : ViewModel() {\n    private val _counter = MutableLiveData(0)\n    val counter: LiveData&lt;Int&gt; = _counter\n\n    fun increment() {\n        _counter.value = (_counter.value ?: 0) + 1\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: CounterViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        viewModel.counter.observe(this) { count -&gt;\n            textView.text = count.toString()\n        }\n\n        button.setOnClickListener {\n            viewModel.increment()\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#cicle-de-vida-del-viewmodel-vs-activityfragment","title":"Cicle de vida del ViewModel vs Activity/Fragment","text":"<p>El ViewModel t\u00e9 un cicle de vida diferent i m\u00e9s llarg que l'Activity o Fragment que l'utilitza.</p> <p>Cicle de vida:</p> <pre><code>ActivityCreatedDestroyed (rotation) \u2192 Re-created \u2192 Finished\n    \u2502                    \u2502                \u2502            \u2502\n    \u25bc                    \u2502                \u2502            \u25bc\nViewModel Created        \u2502                \u2502        onCleared()\n    \u2502                    \u2502                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         (ViewModel es mant\u00e9 viu)\n</code></pre> <p>Exemple pr\u00e0ctic:</p> <pre><code>class MyViewModel : ViewModel() {\n    init {\n        Log.d(\"ViewModel\", \"ViewModel creat\")\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        Log.d(\"ViewModel\", \"ViewModel destru\u00eft\")\n        // Neteja recursos: cancel\u00b7lar coroutines, tancar connexions, etc.\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: MyViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        Log.d(\"Activity\", \"onCreate\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"Activity\", \"onDestroy\")\n    }\n}\n</code></pre> <p>Logs en rotar la pantalla:</p> <pre><code>ViewModel creat\nActivity onCreate\nActivity onDestroy (rotaci\u00f3)\nActivity onCreate (nova inst\u00e0ncia)\n// ViewModel segueix viu!\n\n// Nom\u00e9s quan tanquem l'Activity:\nActivity onDestroy\nViewModel destru\u00eft\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#supervivencia-a-canvis-de-configuracio-rotacions","title":"Superviv\u00e8ncia a canvis de configuraci\u00f3 (rotacions)","text":"<p>El ViewModel sobreviu autom\u00e0ticament a canvis de configuraci\u00f3 com rotacions, canvis d'idioma, etc.</p> <p>El problema sense ViewModel:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    private var userData: User? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Cada cop que rotes, has de tornar a carregar les dades\n        // i si s'han modificat, es perden les modificacions\n        userData=loadUserData() // Crida a l'API, base de dades...\n\n    }\n}\n</code></pre> <p>La soluci\u00f3 amb ViewModel:</p> <pre><code>class UserViewModel : ViewModel() {\n    private val _userData = MutableLiveData&lt;User&gt;()\n    val userData: LiveData&lt;User&gt; = _userData\n\n    init {\n        loadUserData() // Nom\u00e9s es crida UNA vegada\n    }\n\n    //loadUserData obt\u00e9 l'usuari de una bbdd, api, etc..\n    private fun loadUserData() {\n        //obtenir l'usuari de manera as\u00edncronta (veure corrutines)\n        viewModelScope.launch {\n            _userData.value = \"Usuari1\"\n        }\n    }\n}\n\nclass MainActivity : AppCompatActivity() {\n    private val viewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Les dades ja estan disponibles despr\u00e9s de rotar\n        viewModel.userData.observe(this) { user -&gt;\n            textView.text = user.name\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Arquitectura/viewmodel/#2-ambits-scopes","title":"2-\u00c0mbits (Scopes)","text":""},{"location":"Android/Arquitectura/viewmodel/#viewmodel-no-compartit-viewmodels","title":"ViewModel no compartit (viewModels())","text":"<p>Cada Activity o Fragment t\u00e9 la seva pr\u00f2pia inst\u00e0ncia del ViewModel. \u00c0mbit d'Activity:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    // ViewModel amb \u00e0mbit d'aquesta Activity\n    private val viewModel: MyViewModel by viewModels()\n}\n\nclass OtherActivity : AppCompatActivity() {\n    // Inst\u00e0ncia DIFERENT del mateix ViewModel\n    private val viewModel: MyViewModel by viewModels()\n}\n</code></pre> <p>\u00c0mbit de Fragment:</p> <pre><code>class FirstFragment : Fragment() {\n    // ViewModel amb \u00e0mbit d'aquest Fragment\n    private val viewModel: MyViewModel by viewModels()\n}\n\nclass SecondFragment : Fragment() {\n    // Inst\u00e0ncia DIFERENT, incl\u00fas si estan a la mateixa Activity\n    private val viewModel: MyViewModel by viewModels()\n}\n</code></pre> <p>Quan utilitzar-ho:</p> <p>Dades espec\u00edfiques d'una \u00fanica pantalla No necessites compartir informaci\u00f3 entre components L\u00f2gica a\u00efllada d'un sol Fragment</p>"},{"location":"Android/Arquitectura/viewmodel/#viewmodel-compartit-activityviewmodels","title":"ViewModel compartit (activityViewModels())","text":"<p>Diversos Fragments dins de la mateixa Activity poden accedir a la mateixa inst\u00e0ncia del ViewModel. Exemple de comunicaci\u00f3 entre Fragments:</p> <pre><code>class SharedViewModel : ViewModel() {\n    private val _selectedItem = MutableLiveData&lt;Item&gt;()\n    val selectedItem: LiveData&lt;Item&gt; = _selectedItem\n\n    fun selectItem(item: Item) {\n        _selectedItem.value = item\n    }\n}\n\nclass ListFragment : Fragment() {\n    // Obt\u00e9 el ViewModel de l'Activity pare\n    private val sharedViewModel: SharedViewModel by activityViewModels()\n\n    private fun onItemClicked(item: Item) {\n        sharedViewModel.selectItem(item)\n    }\n}\n\nclass DetailFragment : Fragment() {\n    // La MATEIXA inst\u00e0ncia del ViewModel\n    private val sharedViewModel: SharedViewModel by activityViewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        sharedViewModel.selectedItem.observe(viewLifecycleOwner) { item -&gt;\n            // Mostra els detalls de l'item seleccionat\n            textView.text = item.name\n        }\n    }\n}\n</code></pre> <p>Diagrama:</p> <pre><code>MainActivity\n    \u2502\n    \u251c\u2500 SharedViewModel (\u00fanica inst\u00e0ncia)\n    \u2502\n    \u251c\u2500 ListFragment \u2500\u2500\u2192 activityViewModels() \u2500\u2500\u2192 SharedViewModel\n    \u2502\n    \u2514\u2500 DetailFragment \u2500\u2500\u2192 activityViewModels() \u2500\u2500\u2192 SharedViewModel\n                            (mateixa inst\u00e0ncia!)\n</code></pre> <p>Quan utilitzar-ho:</p> <ul> <li>Comunicaci\u00f3 entre Fragments</li> <li>Compartir estat dins d'una Activity</li> <li>Navegaci\u00f3 amb dades (passar informaci\u00f3 entre pantalles)</li> <li>Patr\u00f3 Master-detail</li> </ul>"},{"location":"Android/Arquitectura/viewmodel/#3-viewmodelprovider-i-factories","title":"3-ViewModelProvider i Factories","text":"<p>Quan el ViewModel necessita par\u00e0metres al constructor, \u00e9s necessari implementar un patr\u00f3 factory, per poder passar les dades. Es fa aix\u00ed:</p> <p>ViewModel amb par\u00e0metres:</p> <pre><code>class UserViewModel(\n    private val userId: String,\n    private val repository: UserRepository\n) : ViewModel() {\n\n    private val _user = MutableLiveData&lt;User&gt;()\n    val user: LiveData&lt;User&gt; = _user\n\n    init {\n        loadUser()\n    }\n\n    private fun loadUser() {\n        viewModelScope.launch {\n            _user.value = repository.getUser(userId)\n        }\n    }\n}\n</code></pre> <p>Crear un Factory:</p> <pre><code>class UserViewModelFactory(\n    private val userId: String,\n    private val repository: UserRepository\n) : ViewModelProvider.Factory {\n\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(UserViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return UserViewModel(userId, repository) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre> <p>Utilitzar el Factory:</p> <pre><code>class UserActivity : AppCompatActivity() {\n\n    private val viewModel: UserViewModel by viewModels {\n        UserViewModelFactory(\n            userId = intent.getStringExtra(\"USER_ID\") ?: \"\",\n            repository = UserRepository()\n        )\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        viewModel.user.observe(this) { user -&gt;\n            textView.text = user.name\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/bottommenu/","title":"Bottom Menu","text":""},{"location":"Android/Interficies/bottommenu/#menu-de-navegacio-inferior-bottomnavigationview","title":"Men\u00fa de Navegaci\u00f3 Inferior (BottomNavigationView)","text":"<p>El BottomNavigationView gestiona la navegaci\u00f3 de nivell superior entre un nombre redu\u00eft de vistes principals. Explicaci\u00f3 sense NavController.</p> <p>XML de Men\u00fa de la Navegaci\u00f3 Inferior</p> <p>Aquest fitxer defineix els \u00edtems, per\u00f2 la seva funci\u00f3 principal \u00e9s la navegaci\u00f3 entre fragments, no les accions.</p> <p>Exemple: Recurs de Men\u00fa (res/menu/bottom_nav_menu.xml)</p> <pre><code>\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;item\n        android:id=\"@+id/home_fragment\"\n        android:icon=\"@drawable/ic_home\"\n        android:title=\"Inici\" /&gt;\n    &lt;item\n        android:id=\"@+id/dashboard_fragment\"\n        android:icon=\"@drawable/ic_dashboard\"\n        android:title=\"Panell\" /&gt;\n    &lt;item\n        android:id=\"@+id/notifications_fragment\"\n        android:icon=\"@drawable/ic_notifications\"\n        android:title=\"Avisos\" /&gt;\n&lt;/menu&gt;\n</code></pre> <p>Exemple: Layout de l'activity</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"&gt;\n\n    &lt;androidx.fragment.app.FragmentContainerView\n        android:id=\"@+id/fragment_container\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintBottom_toTopOf=\"@id/bottom_navigation\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" /&gt;\n\n    &lt;com.google.android.material.bottomnavigation.BottomNavigationView\n        android:id=\"@+id/bottom_navigation\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?android:attr/windowBackground\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:menu=\"@menu/bottom_nav_menu\" /&gt; \n    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre> <p>Exemple: Gesti\u00f3 Manual de la Navegaci\u00f3 (Kotlin)</p> <pre><code>\n// ...\nval bottomNav: BottomNavigationView = findViewById(R.id.bottom_navigation)\n\nbottomNav.setOnItemSelectedListener { item -&gt;\n    val selectedFragment: Fragment? = when (item.itemId) {\n        R.id.home_fragment -&gt; HomeFragment()\n        R.id.dashboard_fragment -&gt; DashboardFragment()\n        R.id.notifications_fragment -&gt; NotificationsFragment()\n        else -&gt; null\n    }\n\n    // Realitza la transacci\u00f3 de Fragment manualment\n    if (selectedFragment != null) {\n        supportFragmentManager.beginTransaction()\n            .replace(R.id.fragment_container, selectedFragment)\n            .commit()\n    }\n    true // Indica que la selecci\u00f3 ha estat gestionada\n}\n// ...\n</code></pre>"},{"location":"Android/Interficies/dialegs/","title":"Dialogs i dialogfragment","text":"<p>Obtenir valors dels dialogs.  Del video curso kotlin part 1 Minut 8:34:28</p> <p>Utilitzant dialogfragment i una subclasse d'aquest: Oficial: https://developer.android.com/guide/fragments/dialogs</p> <p>exemple https://www.youtube.com/watch?v=CXggjg9s4NA Interessant per utilitzar interface per retornar un objecte del dialog. Minut 15:00</p>"},{"location":"Android/Interficies/drawermenu/","title":"Drawermenu","text":""},{"location":"Android/Interficies/drawermenu/#1-drawer-menu","title":"1. Drawer Men\u00fa","text":"<p>Es presenta com un panell vertical que roman ocult i es fa visible lliscant-lo (normalment des de la vora esquerra de la pantalla, depenent de la configuraci\u00f3 de l'idioma) o prement la icona de men\u00fa/hamburguesa a la barra superior de l'aplicaci\u00f3.</p> <p>La seva funci\u00f3 principal \u00e9s estalviar espai a la pantalla i mantenir la interf\u00edcie neta, ja que agrupa les opcions de navegaci\u00f3 menys freq\u00fcentment utilitzades o que porten a pantalles de nivell superior, proporcionant un \u00fanic punt de salt a qualsevol secci\u00f3 principal de l'aplicaci\u00f3.</p>"},{"location":"Android/Interficies/drawermenu/#2-implementacio","title":"2. Implementaci\u00f3","text":""},{"location":"Android/Interficies/drawermenu/#recurs-de-menu-xml","title":"Recurs de Men\u00fa (XML)","text":"<p>Crea un nou fitxer de recurs de men\u00fa a res/menu/main_drawer_menu.xml. Aquest fitxer defineix els \u00edtems que es mostraran al panell lateral.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;group android:checkableBehavior=\"single\"&gt;\n        &lt;item\n            android:id=\"@+id/nav_home\"\n            android:icon=\"@drawable/ic_home\"\n            android:title=\"Inici\" /&gt;\n        &lt;item\n            android:id=\"@+id/nav_gallery\"\n            android:icon=\"@drawable/ic_gallery\"\n            android:title=\"Galeria\" /&gt;\n        &lt;item\n            android:id=\"@+id/nav_settings\"\n            android:icon=\"@drawable/ic_settings\"\n            android:title=\"Configuraci\u00f3\" /&gt;\n    &lt;/group&gt;\n    &lt;item android:title=\"Comunicaci\u00f3\"&gt;\n        &lt;menu&gt;\n            &lt;item\n                android:id=\"@+id/nav_share\"\n                android:icon=\"@drawable/ic_share\"\n                android:title=\"Compartir\" /&gt;\n        &lt;/menu&gt;\n    &lt;/item&gt;\n&lt;/menu&gt;\n</code></pre>"},{"location":"Android/Interficies/drawermenu/#disseny-del-layout","title":"Disseny del Layout","text":"<p>El DrawerLayout \u00e9s el contenidor principal. Ha de contenir dos elements: el contingut principal de l'aplicaci\u00f3 i el panell de navegaci\u00f3.</p>"},{"location":"Android/Interficies/drawermenu/#21-activity_mainxml","title":"2.1 activity_main.xml","text":"<pre><code>&lt;androidx.drawerlayout.widget.DrawerLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" \n    tools:openDrawer=\"start\"&gt;\n\n    &lt;include\n        layout=\"@layout/app_bar_main\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" /&gt;\n\n    &lt;com.google.android.material.navigation.NavigationView\n        android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" \n        android:fitsSystemWindows=\"true\"\n        app:headerLayout=\"@layout/nav_header_main\" \n        app:menu=\"@menu/main_drawer_menu\" /&gt;\n\n&lt;/androidx.drawerlayout.widget.DrawerLayout&gt;\n</code></pre> <ul> <li>DrawerLayout: L'arrel.12android:layout_gravity=\"start\": Crucial. Indica al DrawerLayout que el NavigationView \u00e9s el panell lateral i ha d'apar\u00e8ixer des de la vora inicial (esquerra, en la majoria d'idiomes).</li> <li>app:menu: Enlla\u00e7a amb el fitxer de men\u00fa XML creat anteriorment.</li> </ul>"},{"location":"Android/Interficies/drawermenu/#22-implementacio-de-la-logica","title":"2.2 Implementaci\u00f3 de la L\u00f2gica","text":"<p>La l\u00f2gica es realitza a la MainActivity.kt. </p> <p>Es centra a sincronitzar el Drawer amb la barra d'eines i gestionar els clics.</p> <p>Exemple:</p> <pre><code>import androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.view.MenuItem\nimport android.widget.Toast\nimport androidx.appcompat.app.ActionBarDrawerToggle\nimport androidx.core.view.GravityCompat\nimport com.google.android.material.navigation.NavigationView\nimport androidx.drawerlayout.widget.DrawerLayout\n\nclass MainActivity : AppCompatActivity(), \n                     NavigationView.OnNavigationItemSelectedListener { // 1. Implementa el Listener\n\n    private lateinit var drawerLayout: DrawerLayout\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 2. Obtenci\u00f3 de les vistes\n        drawerLayout = findViewById(R.id.drawer_layout)\n        val navView: NavigationView = findViewById(R.id.nav_view)\n\n        // La Toolbar (assumint que s'ha incl\u00f2s a app_bar_main i se li ha assignat un ID 'toolbar')\n        val toolbar: androidx.appcompat.widget.Toolbar = findViewById(R.id.toolbar)\n        setSupportActionBar(toolbar) // Opcional: Si vols usar la Toolbar com a ActionBar\n\n        // 3. Sincronitzaci\u00f3 amb la Barra d'Eines (Icona d'Hamburguesa)\n        val toggle = ActionBarDrawerToggle(\n            this, \n            drawerLayout, \n            toolbar, \n            R.string.navigation_drawer_open, // String de recurs: \"Open navigation drawer\"\n            R.string.navigation_drawer_close // String de recurs: \"Close navigation drawer\"\n        )\n        drawerLayout.addDrawerListener(toggle)\n        toggle.syncState() // Sincronitza l'estat inicial de la icona\n\n        // 4. Establir el Listener per als Clics al Men\u00fa\n        navView.setNavigationItemSelectedListener(this)\n    }\n\n    // 5. Gesti\u00f3 dels Clics al Men\u00fa (Implementaci\u00f3 del Listener)\n    override fun onNavigationItemSelected(item: MenuItem): Boolean {\n        when (item.itemId) {\n            R.id.nav_home -&gt; {\n                Toast.makeText(this, \"Inici seleccionat\", Toast.LENGTH_SHORT).show()\n                // Aqu\u00ed va la l\u00f2gica per canviar Fragment / Activity\n            }\n            R.id.nav_gallery -&gt; {\n                Toast.makeText(this, \"Galeria seleccionada\", Toast.LENGTH_SHORT).show()\n            }\n            R.id.nav_settings -&gt; {\n                Toast.makeText(this, \"Configuraci\u00f3 seleccionada\", Toast.LENGTH_SHORT).show()\n            }\n            R.id.nav_share -&gt; {\n                Toast.makeText(this, \"Compartir seleccionat\", Toast.LENGTH_SHORT).show()\n            }\n        }\n\n        // Tanca el Drawer un cop s'ha seleccionat l'\u00edtem\n        drawerLayout.closeDrawer(GravityCompat.START)\n        return true\n    }\n\n    // 6. Gesti\u00f3 del Bot\u00f3 Enrere\n    override fun onBackPressed() {\n        if (drawerLayout.isDrawerOpen(GravityCompat.START)) {\n            // Si el Drawer est\u00e0 obert, el tanquem\n            drawerLayout.closeDrawer(GravityCompat.START)\n        } else {\n            // Si el Drawer est\u00e0 tancat, es permet la funci\u00f3 normal del bot\u00f3 Enrere\n            super.onBackPressed()\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/drawermenu/#3-resum-de-punts-clau","title":"3. Resum de Punts Clau","text":"Component Funci\u00f3 Notes Clau DrawerLayout Contenidor arrel que permet l'acci\u00f3 de lliscament. Ha de tenir dos fills: el contingut principal i el panell lateral. NavigationView El panell lateral amb el men\u00fa d'elements. Utilitza android:layout_gravity=\"start\" i app:menu. ActionBarDrawerToggle Classe que gestiona la interacci\u00f3 amb la Toolbar. S'encarrega de mostrar la icona d'hamburguesa i obrir/tancar el Drawer al clicar. onNavigationItemSelected M\u00e8tode del NavigationView. OnNavigationItemSelectedListener. On s'implementa la l\u00f2gica de navegaci\u00f3 real (Fragments, Activities). S'ha de tancar el Drawer despr\u00e9s de l'acci\u00f3. onBackPressed() M\u00e8tode de l'Activity. Es sobreescriu per interceptar el bot\u00f3 Enrere i tancar el Drawer abans de sortir de l'Activity."},{"location":"Android/Interficies/layouts/","title":"Layouts","text":""},{"location":"Android/Interficies/layouts/#linear-layout","title":"Linear Layout","text":""},{"location":"Android/Interficies/layouts/#contraint-layout","title":"Contraint Layout","text":""},{"location":"Android/Interficies/layouts/#chains","title":"Chains","text":""},{"location":"Android/Interficies/toolbar/","title":"Toolbar","text":""},{"location":"Android/Interficies/toolbar/#1-la-toolbar-com-a-appbar-fonaments","title":"1. La Toolbar com a AppBar (Fonaments)","text":""},{"location":"Android/Interficies/toolbar/#concepte-i-funcio","title":"Concepte i Funci\u00f3","text":"<p>L'AppBar (Barra d'Aplicacions) \u00e9s el component estructural m\u00e9s important a la part superior de qualsevol pantalla Android. </p> <p>El seu prop\u00f2sit \u00e9s: - Identitat: Mostrar el t\u00edtol de l'aplicaci\u00f3 o la pantalla actual. - Navegaci\u00f3: Allotjar el bot\u00f3 \"Up\" (fletxa enrere) o la icona del Navigation Drawer. - Accions: Contenir les accions m\u00e9s importants de la pantalla (men\u00fas).</p> <p>La Toolbar (proporcionada per la biblioteca AndroidX Material Components) \u00e9s la implementaci\u00f3 moderna i flexible de l'AppBar. A difer\u00e8ncia de l'antiga ActionBar nativa, la Toolbar pot ser col\u00b7locada a qualsevol lloc d'un layout i personalitzada amb facilitat.</p>"},{"location":"Android/Interficies/toolbar/#implementacio-basica","title":"Implementaci\u00f3 B\u00e0sica","text":"<p>Per utilitzar una Toolbar, primer s'ha d'afegir al fitxer XML del layout de l'Activity. Exemple: XML del Layout (activity_main.xml)</p> <pre><code>&lt;LinearLayout \n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;androidx.appcompat.widget.Toolbar\n        android:id=\"@+id/my_toolbar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"?attr/actionBarSize\"\n        android:background=\"?attr/colorPrimary\"\n        android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" /&gt; \n\n    &lt;TextView \n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"El contingut de l'Activity va aqu\u00ed\"\n        android:padding=\"16dp\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre> <p>Despr\u00e9s, s'ha de configurar aquesta Toolbar com l'Action Bar de l'Activity en el codi Kotlin/Java, despr\u00e9s d'ocultar la barra nativa al tema de l'aplicaci\u00f3 (normalment, s'usa un tema NoActionBar), amb la funci\u00f3 setSupportActionBar</p> <p>Exemple: Configuraci\u00f3 a l'Activity (Kotlin)</p> <pre><code>import androidx.appcompat.app.AppCompatActivity\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val toolbar = findViewById&lt;Toolbar&gt;(R.id.my_toolbar)\n        // 1. Configura la Toolbar com l'Action Bar del sistema\n        setSupportActionBar(toolbar) \n\n        // Opcional: Estableix un t\u00edtol\n        supportActionBar?.title = \"La Meva App\" \n    }\n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#2-afegir-menus-a-la-toolbar","title":"2. Afegir Men\u00fas a la Toolbar","text":""},{"location":"Android/Interficies/toolbar/#definicio-del-menu","title":"Definici\u00f3 del Men\u00fa","text":"<p>Els \u00edtems del men\u00fa es defineixen en un fitxer XML separat a res/menu/.</p> <p>Exemple: Recurs de Men\u00fa (res/menu/main_menu.xml)</p> <pre><code>&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt;\n\n    &lt;item\n        android:id=\"@+id/action_cercar\"\n        android:icon=\"@drawable/ic_search\" \n        android:title=\"Cercar\"\n        app:showAsAction=\"ifRoom\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/action_configuracio\"\n        android:title=\"Configuraci\u00f3\"\n        app:showAsAction=\"never\" /&gt;\n\n&lt;/menu&gt;\n</code></pre>"},{"location":"Android/Interficies/toolbar/#inflacio","title":"Inflaci\u00f3","text":"<p>El proc\u00e9s d'inflar (carregar) el men\u00fa XML a la Toolbar es fa sobreescrivint el m\u00e8tode onCreateOptionsMenu() de l'Activity. Exemple: Inflaci\u00f3 del Men\u00fa (Kotlin)</p> <pre><code>class MainActivity : AppCompatActivity() {\n    // ... onCreate ...\n\n    override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n        // 1. Carrega el recurs de men\u00fa a l'Activity\n        menuInflater.inflate(R.menu.main_menu, menu)\n        return true // Retorna true per mostrar el men\u00fa\n    }\n    // ...\n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#gestio-de-clics-i-prioritat","title":"Gesti\u00f3 de Clics i Prioritat","text":"<p>Per respondre a les interaccions de l'usuari amb els \u00edtems del men\u00fa, s'ha de sobreescriure el m\u00e8tode onOptionsItemSelected(). Exemple 2.3: Gesti\u00f3 de Clics (Kotlin)</p> <pre><code>    // ...\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            R.id.action_cercar -&gt; {\n                // L\u00f2gica per a l'acci\u00f3 de cercar\n                Toast.makeText(this, \"S'ha premut Cerca\", Toast.LENGTH_SHORT).show()\n                true\n            }\n            R.id.action_configuracio -&gt; {\n                // L\u00f2gica per anar a Configuraci\u00f3\n                Toast.makeText(this, \"Obrint Configuraci\u00f3...\", Toast.LENGTH_SHORT).show()\n                true\n            }\n            else -&gt; super.onOptionsItemSelected(item)\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#3-gestio-de-la-navegacio-a-lappbar","title":"3. Gesti\u00f3 de la Navegaci\u00f3 a l'AppBar","text":""},{"location":"Android/Interficies/toolbar/#el-boto-up","title":"El Bot\u00f3 \"Up\"","text":"<p>El bot\u00f3 \"Up\" (representat t\u00edpicament per una fletxa cap a l'esquerra: $\\leftarrow$) \u00e9s una convenci\u00f3 de disseny que permet a l'usuari navegar cap amunt en la jerarquia l\u00f2gica de l'aplicaci\u00f3, fins a la pantalla pare. </p> <p>\u00c9s diferent del bot\u00f3 \"Enrere\" del sistema, que navega pel registre hist\u00f2ric (back stack).</p>"},{"location":"Android/Interficies/toolbar/#integracio-de-la-navegacio","title":"Integraci\u00f3 de la Navegaci\u00f3","text":"<p>Quan s'utilitza la Toolbar com a Action Bar, el sistema pot gestionar autom\u00e0ticament el comportament del bot\u00f3 \"Up\" basant-se en la definici\u00f3 de l'Activity al fitxer AndroidManifest.xml (especificant l'Activity pare amb android:parentActivityName).</p> <p>Si no s'utilitza la Navigation Library, es pot habilitar el bot\u00f3 manualment i gestionar el seu clic:</p> <p>Exemple: Habilitaci\u00f3 del Bot\u00f3 \"Up\" (Kotlin)</p> <pre><code>class DetailActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // ...\n\n        // Habilita el bot\u00f3 \"Up\" a la Toolbar\n        supportActionBar?.setDisplayHomeAsUpEnabled(true) \n    }\n\n    // Gesti\u00f3 manual del clic al bot\u00f3 \"Up\"\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            android.R.id.home -&gt; {\n                // El m\u00e8tode navigateUpFromSameTask() de l'Activity Manager \n                // compleix la funci\u00f3 del bot\u00f3 \"Up\"\n                NavUtils.navigateUpFromSameTask(this) \n                true\n            }\n            else -&gt; super.onOptionsItemSelected(item)\n        }\n    }\n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#4-actualitzacio-dinamica-dels-menus","title":"4. Actualitzaci\u00f3 Din\u00e0mica dels Men\u00fas","text":"<p>De vegades, l'estat d'un \u00edtem de men\u00fa (p. ex., canviar una icona de \"No Favorit\" a \"Favorit\") ha de canviar mentre l'Activity est\u00e0 oberta.</p>"},{"location":"Android/Interficies/toolbar/#invalidacio-del-menu","title":"Invalidaci\u00f3 del Men\u00fa","text":"<p>Per for\u00e7ar que el sistema torni a cridar a onCreateOptionsMenu() i recre\u00ef completament el men\u00fa, s'utilitza invalidateOptionsMenu(). </p> <p>Aix\u00f2 \u00e9s \u00fatil si la visibilitat o el t\u00edtol d'alguns \u00edtems dep\u00e8n d'un estat global que acaba de canviar. Exemple: For\u00e7ar la Recreaci\u00f3 del Men\u00fa (Kotlin)</p> <pre><code>// Despr\u00e9s d'un canvi d'estat a la nostra Activity...\nfun onDataUpdated() {\n    // ... \n    // Crida a invalidateOptionsMenu() per recrear el men\u00fa amb les noves dades\n    invalidateOptionsMenu() \n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#preparacio-del-menu","title":"Preparaci\u00f3 del Men\u00fa","text":"<p>El m\u00e8tode onPrepareOptionsMenu() es crida just abans que es mostri el men\u00fa. Aquest \u00e9s el lloc ideal per canviar la visibilitat o l'aparen\u00e7a dels \u00edtems de men\u00fa existents sense recrear tota l'estructura.</p> <p>Exemple: Preparaci\u00f3 Din\u00e0mica (Kotlin)</p> <pre><code>// Variable d'estat a l'Activity\nprivate var isUserLoggedIn = false\n\noverride fun onPrepareOptionsMenu(menu: Menu?): Boolean {\n    val loginItem = menu?.findItem(R.id.action_login)\n    val logoutItem = menu?.findItem(R.id.action_logout)\n\n    // Mostra l'opci\u00f3 de login si l'usuari no est\u00e0 connectat, i viceversa\n    loginItem?.isVisible = !isUserLoggedIn\n    logoutItem?.isVisible = isUserLoggedIn\n\n    return super.onPrepareOptionsMenu(menu)\n}\n</code></pre>"},{"location":"Android/Interficies/toolbar/#5-action-views","title":"5. Action Views","text":"<p>Vegeu documentaci\u00f3 per a detalls: https://developer.android.com/develop/ui/views/components/appbar/action-views</p>"},{"location":"Android/Interficies/toolbar/#action-views","title":"Action Views","text":"<p>Un Action View \u00e9s un widget personalitzat (per exemple, un EditText, un SearchView, o un ProgressBar) que s'associa a un \u00edtem de men\u00fa. En lloc de mostrar la icona i el text habituals, l'\u00edtem de men\u00fa mostra el widget de l'Action View directament a la Toolbar. Caracter\u00edstiques: - Widget Incrustat: El SearchView \u00e9s l'exemple m\u00e9s com\u00fa. Quan l'usuari el selecciona, el widget s'expandeix a la barra d'aplicacions, permetent interaccions complexes (escriure, enviar) sense canviar d'Activity o mostrar un di\u00e0leg.</p> <ul> <li> <p>Implementaci\u00f3: Es defineix mitjan\u00e7ant l'atribut app:actionViewClass o android:actionLayout a l'XML del men\u00fa. Tamb\u00e9 es pot inflar manualment en el m\u00e8tode onCreateOptionsMenu().</p> </li> <li> <p>Gesti\u00f3 de Col\u00b7lapse: Quan l'Action View s'expandeix, altres accions de la Toolbar es poden col\u00b7lapsar (amagar). Pots implementar la interf\u00edcie MenuItem.OnActionExpandListener per gestionar esdeveniments quan l'acci\u00f3 s'expandeix o es col\u00b7lapsa.</p> </li> </ul> Searchview sense focus Searchview amb focus"},{"location":"Android/Patrons/","title":"Patrons de disseny: SOLID","text":"<p>https://www.freecodecamp.org/espanol/news/los-principios-solid-explicados-en-espanol/</p> <p>Com recodificar una app: exemple principis solid: https://www.youtube.com/live/LEC_a7qBrKU</p>"},{"location":"Arduino/rc522/","title":"lliberia RC522","text":""},{"location":"Arduino/rc522/#v","title":"V","text":""},{"location":"Arduino/wifi/","title":"Connectar Arduino a Wifi","text":""},{"location":"Arduino/wifi/#llibreria","title":"llibreria","text":""},{"location":"Arduino/wifi/#codi","title":"codi","text":""},{"location":"Exemples/","title":"Adreces de github amb exemples","text":""},{"location":"Exemples/#1-recycler-view","title":"1. Recycler view","text":""},{"location":"Exemples/#2-rollingdiceclean","title":"2. RollingDiceClean","text":""}]}